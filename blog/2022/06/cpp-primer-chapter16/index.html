<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222"><meta name="generator" content="Hexo 6.2.0">

<link rel="preconnect" href="https://fonts.lug.ustc.edu.cn" crossorigin>
<link rel="preconnect" href="https://cdn.jsdelivr.net" crossorigin>
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16.png">
  <link rel="mask-icon" href="/images/safari-pinned-tab.svg" color="#222">
  <link rel="manifest" href="/images/site.webmanifest">

<link rel="stylesheet" href="/css/main.css">

<link rel="stylesheet" href="https://fonts.lug.ustc.edu.cn/css?family=Noto+Serif+SC:300,300italic,400,400italic,700,700italic%7CSF+Mono+Regular:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext">

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6.1.1/css/all.min.css" integrity="sha256-DfWjNxDkM94fVBWx1H5BMMp0Zq7luBlV8QRcSES7s+0=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/animate.css@3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"pangwong.github.io","root":"/","images":"/images","scheme":"Mist","darkmode":false,"version":"8.11.1","exturl":false,"sidebar":{"position":"right","display":"post","padding":18,"offset":12},"copycode":true,"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":true,"lazyload":true,"pangu":true,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"}}</script><script src="/js/config.js"></script>

    <meta name="description" content="Template and Generic Programming">
<meta property="og:type" content="article">
<meta property="og:title" content="Reading Note of CppPrimer-Chapter16">
<meta property="og:url" content="https://pangwong.github.io/blog/2022/06/cpp-primer-chapter16/index.html">
<meta property="og:site_name" content="曰悦鸟">
<meta property="og:description" content="Template and Generic Programming">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2022-06-20T09:30:31.000Z">
<meta property="article:modified_time" content="2022-06-20T16:59:02.606Z">
<meta property="article:author" content="PangWong">
<meta property="article:tag" content="reading notes">
<meta property="article:tag" content="cpp-primer">
<meta property="article:tag" content="template">
<meta property="article:tag" content="function template">
<meta property="article:tag" content="class template">
<meta property="article:tag" content="typename">
<meta property="article:tag" content="member template">
<meta property="article:tag" content="explicit instantiation">
<meta property="article:tag" content="reference collapsing">
<meta property="article:tag" content="std::move">
<meta property="article:tag" content="std::forward">
<meta property="article:tag" content="variadic template">
<meta property="article:tag" content="pack expansion">
<meta property="article:tag" content="template full specialization">
<meta property="article:tag" content="template partial specialization">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="https://pangwong.github.io/blog/2022/06/cpp-primer-chapter16/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"zh-CN","comments":true,"permalink":"https://pangwong.github.io/blog/2022/06/cpp-primer-chapter16/","path":"/blog/2022/06/cpp-primer-chapter16/","title":"Reading Note of CppPrimer-Chapter16"}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>Reading Note of CppPrimer-Chapter16 | 曰悦鸟</title>
  





  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <p class="site-title">曰悦鸟</p>
      <i class="logo-line"></i>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a></li><li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a></li>
  </ul>
</nav>




</div>
        
  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>

  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
            <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#Template-and-Generic-Programming"><span class="nav-number">1.</span> <span class="nav-text">Template and Generic Programming</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Template-Definition"><span class="nav-number">1.1.</span> <span class="nav-text">Template Definition</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Template-Compilation"><span class="nav-number">1.2.</span> <span class="nav-text">Template Compilation</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Template-Argument-Deduction"><span class="nav-number">1.3.</span> <span class="nav-text">Template Argument Deduction</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Overloading-and-Template"><span class="nav-number">1.4.</span> <span class="nav-text">Overloading and Template</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Variadic-Template"><span class="nav-number">1.5.</span> <span class="nav-text">Variadic Template</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Template-Specialization"><span class="nav-number">1.6.</span> <span class="nav-text">Template Specialization</span></a></li></ol></li></ol></div>
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author site-overview-item animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="PangWong"
      src="/images/avatar.png">
  <p class="site-author-name" itemprop="name">PangWong</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap site-overview-item animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">15</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/categories/">
        <span class="site-state-item-count">1</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/tags/">
        <span class="site-state-item-count">133</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author site-overview-item animated">
      <span class="links-of-author-item">
        <a href="https://github.com/pangwong" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;pangwong" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
  </div>



        </div>
      </div>
    </div>
  </aside>
  <div class="sidebar-dimmer"></div>


    </header>

    
  <div class="back-to-top" role="button" aria-label="返回顶部">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>
  <div class="reading-progress-bar"></div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


    <div class="main-inner post posts-expand">


  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://pangwong.github.io/blog/2022/06/cpp-primer-chapter16/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="PangWong">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="曰悦鸟">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="Reading Note of CppPrimer-Chapter16 | 曰悦鸟">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          Reading Note of CppPrimer-Chapter16
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2022-06-20 17:30:31" itemprop="dateCreated datePublished" datetime="2022-06-20T17:30:31+08:00">2022-06-20</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2022-06-21 00:59:02" itemprop="dateModified" datetime="2022-06-21T00:59:02+08:00">2022-06-21</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/C/" itemprop="url" rel="index"><span itemprop="name">C++</span></a>
        </span>
    </span>

  
    <span class="post-meta-item" title="阅读次数" id="busuanzi_container_page_pv">
      <span class="post-meta-item-icon">
        <i class="far fa-eye"></i>
      </span>
      <span class="post-meta-item-text">阅读次数：</span>
      <span id="busuanzi_value_page_pv"></span>
    </span>
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>38k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>34 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
        <h2 id="Template-and-Generic-Programming"><a href="#Template-and-Generic-Programming" class="headerlink" title="Template and Generic Programming"></a>Template and Generic Programming</h2><span id="more"></span>



<h3 id="Template-Definition"><a href="#Template-Definition" class="headerlink" title="Template Definition"></a>Template Definition</h3><ul>
<li><p>模版的形式</p>
<p>  模版的定义以关键字<code>template</code>开始，后跟一个<code>模版参数列表(template parameters list)</code>，这是一个逗号<code>,</code>分隔的一个或者多个<code>模版参数(template parameters)</code>的列表，用小于号<code>&lt;</code>和大于号<code>&gt;</code>括起来</p>
</li>
<li><p>模版的参数</p>
<ul>
<li><p><strong>模版参数列表很像函数参数列表</strong>，定义了若干特定类型的局部变量但并未指明如何初始化他们；在运行时，由调用者初始化形参</p>
</li>
<li><p><strong>在模版的定义中，模版的参数列表不能为空</strong>；注意区别于<strong>模版特例化</strong></p>
</li>
<li><p>模版的参数分为<strong>类型参数</strong>和<strong>非类型参数</strong></p>
</li>
<li><p>模版参数遵循作用域规则，可以隐藏外层作用域的同名变量，但是<strong>不能在模板内重用模板参数名</strong></p>
  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> A, <span class="keyword">typename</span> B&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(A a, B b)</span></span>&#123;</span><br><span class="line">    A tmp = a;</span><br><span class="line">    <span class="type">double</span> B= <span class="number">0</span>;        <span class="comment">// invalid, can not reuse template parameter name</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>模版<strong>类型参数</strong></p>
<ul>
<li><p>一般来说，可以将类型参数看作是<strong>类型说明符</strong>，就像内置类型或者类类型说明符</p>
</li>
<li><p>在类型参数前需要使用关键字<code>typename</code>或者<code>class</code>，<strong>在模版参数列表中，这两个关键字的含义相同</strong>，甚至可以混合使用</p>
</li>
<li><p>类型参数可以用来指定函数的<strong>返回值类型</strong>或者<strong>函数参数类型</strong>，以及用于<strong>变量声明</strong>或者<strong>类型转换</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function">T <span class="title">foo</span><span class="params">(T* p)</span></span>&#123;            <span class="comment">// return value type, function parameter type</span></span><br><span class="line">    T tmp = *p;       <span class="comment">// define variable</span></span><br><span class="line">    <span class="keyword">return</span> tmp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>可以用<code>void</code>作为类型参数的<strong>默认参数</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T0, <span class="keyword">typename</span> T1 = <span class="type">void</span>, <span class="keyword">typename</span> T2 = <span class="type">void</span>&gt; </span><br><span class="line"><span class="keyword">class</span> Tuple;</span><br></pre></td></tr></table></figure>
</li>
<li><p>模板的默认参数<strong>不仅仅可以是一个确定的类型</strong>，它还能是<strong>以其他类型为参数的一个类型表达式</strong></p>
<blockquote>
<p>在实例化的时候，尽管我们只为<code>SafeDivide</code>指定了参数<code>T</code>，但是它的另一个参数<code>IsFloat</code>在缺省的情况下，可以根据<code>T</code>求出表达式<code>std::is_floating_point&lt;T&gt;::value</code>的值作为实参的值，带入到<code>SafeDivide</code>的匹配中。</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="type">bool</span> IsFloat = std::is_floating_point&lt;T&gt;::value&gt;</span><br><span class="line"><span class="keyword">struct</span> SafeDivide &#123;</span><br><span class="line">    <span class="type">static</span> T <span class="built_in">Do</span>(T lhs, T rhs) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">CustomDiv</span>(lhs, rhs);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; </span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">SafeDivide</span>&lt;T, <span class="literal">true</span>&gt;&#123;     <span class="comment">// 偏特化</span></span><br><span class="line">    <span class="function"><span class="type">static</span> T <span class="title">Do</span><span class="params">(T lhs, T rhs)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> lhs/rhs;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; </span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">SafeDivide</span>&lt;T, <span class="literal">false</span>&gt;&#123;    <span class="comment">// 偏特化</span></span><br><span class="line">    <span class="function"><span class="type">static</span> T <span class="title">Do</span><span class="params">(T lhs, T rhs)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> lhs;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>模版<strong>非类型参数</strong></p>
<ul>
<li><p>一个非类型参数表示<strong>一个值而并非是一个类型</strong>，通过特定的<strong>类型名而不是关键字</strong><code>class</code>或<code>typename</code>来声明</p>
<ul>
<li><p><strong>在C++20之前，非类型参数只可以是<code>整形</code>、指向对象或者函数类型的<code>指针</code>或者<code>左值引用</code></strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="type">float</span> SCORE&gt;</span><br><span class="line"><span class="function"><span class="type">float</span> <span class="title">get_score</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> SCORE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">error: a non-type template parameter cannot have type &#x27;float&#x27; before C++20</span><br><span class="line">template &lt;float SCORE&gt;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>当一个非类型参数模版被实例化时，非类型参数被一个<strong>用户提供</strong>或者<strong>编译器推断</strong>出的值所代替</p>
<ul>
<li><p>用户提供</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">std::array&lt;<span class="type">int</span>, 3&gt;;</span><br></pre></td></tr></table></figure>
</li>
<li><p>编译器推断（<strong>编译器可以为函数模版推断参数，但是不可以给类模版推倒(until C++17)，使用类模版必须在模版名后的尖括号内提供多余信息</strong>）</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="type">unsigned</span> <span class="type">int</span> N, <span class="type">unsigned</span> <span class="type">int</span> M&gt;</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">compare</span><span class="params">(<span class="type">const</span> <span class="type">char</span> (&amp;p1)[N], <span class="type">const</span> <span class="type">char</span> (&amp;p2)[M])</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">strcmp</span>(p1, p2);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">compare</span>(<span class="string">&quot;hi&quot;</span>, <span class="string">&quot;mom&quot;</span>);        <span class="comment">// compile deduced that N=sizeof(&quot;hi&quot;)=3, M=sizeof(&quot;mom&quot;)=4</span></span><br><span class="line"><span class="comment">// equal to user specified parameters</span></span><br><span class="line"><span class="built_in">compare</span>&lt;<span class="number">3</span>, <span class="number">4</span>&gt;(<span class="string">&quot;hi&quot;</span>, <span class="string">&quot;mom&quot;</span>);</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>绑定到非参数类型的<strong>整形参数必须是一个常量表达式</strong>，绑定到非参数类型的<strong>指针或者引用类型必须具有静态生存期</strong></p>
</li>
<li><p>在模版定义内，模版非类型参数是一个<strong>常量值</strong>(<em>constexpr</em>)，<strong>可以用在任何需要使用常量值的地方</strong></p>
</li>
</ul>
</li>
<li><p>访问模板参数的<strong>类型成员</strong>（<em><strong>typename</strong></em>）</p>
<p>一般的类在定义完整的情况下，通过作用域访问一个类成员，是可以知道这个成员时类型还是数据成员；但是模板类不可以，因为在未实例化的时候，编译器得不到更详细的信息</p>
<p>默认情况下，C++语言<strong>假定通过域作用符访问的名字不是类型</strong></p>
<p>如果需要<strong>使用模板参数的类型成员</strong>，需要<strong>显式的告诉编译器该变量是一个类型</strong>，可以通过<code>typename</code>实现而不能用<code>class</code></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">typename</span> T::value_type <span class="title">top</span><span class="params">(<span class="type">const</span> T&amp; c)</span></span>&#123;    <span class="comment">// return T::value_type, specified by typename, indicate </span></span><br><span class="line">    <span class="keyword">if</span> (!c.<span class="built_in">empty</span>())&#123;                       <span class="comment">// it is a type value rather than data member</span></span><br><span class="line">        <span class="keyword">return</span> c.<span class="built_in">back</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">typename</span> T::<span class="built_in">value_type</span>();   <span class="comment">//  specified by typename</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>事实上，标准对<code>typename</code>的使用规定极为复杂，也算是整个模板中的难点之一。如果想了解所有的标准，需要阅读标准14.6节下2-7条，以及14.6.2.1第一条中对于<code>current instantiation</code>的解释。</p>
<p>简单来说，<strong>如果编译器能在出现的时候知道它的类型，那么就不需要<code>typename</code>，如果必须要到实例化的时候才能知道它是不是合法，那么定义的时候就把这个名称作为变量而不是类型</strong>。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">A</span>;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="keyword">struct</span> <span class="title class_">B</span>;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="keyword">struct</span> <span class="title class_">X</span> &#123;</span><br><span class="line">    <span class="keyword">typedef</span> X&lt;T&gt; _A; <span class="comment">// 编译器当然知道 X&lt;T&gt; 是一个类型。</span></span><br><span class="line">    <span class="keyword">typedef</span> X    _B; <span class="comment">// X 等价于 X&lt;T&gt; 的缩写</span></span><br><span class="line">    <span class="keyword">typedef</span> T    _C; <span class="comment">// T 不是一个类型还玩毛</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// ！！！注意我要变形了！！！</span></span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">Y</span> &#123;</span><br><span class="line">        <span class="keyword">typedef</span> X&lt;T&gt;     _D;          <span class="comment">// X 的内部，既然外部高枕无忧，内部更不用说了</span></span><br><span class="line">        <span class="keyword">typedef</span> X&lt;T&gt;::Y  _E;          <span class="comment">// 嗯，这里也没问题，编译器知道Y就是当前的类型，</span></span><br><span class="line">                                      <span class="comment">// 这里在VS2015上会有错，需要添加 typename，</span></span><br><span class="line">                                      <span class="comment">// Clang 上顺利通过。</span></span><br><span class="line">        <span class="keyword">typedef</span> <span class="keyword">typename</span> X&lt;T*&gt;::Y _F; <span class="comment">// 这个居然要加 typename！</span></span><br><span class="line">                                      <span class="comment">// 因为，X&lt;T*&gt;和X&lt;T&gt;不一样哦，</span></span><br><span class="line">                                      <span class="comment">// 它可能会在实例化的时候被别的偏特化给抢过去实现了。</span></span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">typedef</span> A _G;                      <span class="comment">// 嗯，没问题，A在外面声明啦</span></span><br><span class="line">    <span class="keyword">typedef</span> B&lt;T&gt; _H;                   <span class="comment">// B&lt;T&gt;也是一个类型</span></span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">typename</span> B&lt;T&gt;::type _I;    <span class="comment">// 嗯，因为不知道B&lt;T&gt;::type的信息，</span></span><br><span class="line">                                       <span class="comment">// 所以需要typename</span></span><br><span class="line">    <span class="keyword">typedef</span> B&lt;<span class="type">int</span>&gt;::type _J;           <span class="comment">// B&lt;int&gt; 不依赖模板参数，</span></span><br><span class="line">                                       <span class="comment">// 所以编译器直接就实例化（instantiate）了</span></span><br><span class="line">                                       <span class="comment">// 但是这个时候，B并没有被实现，所以就出错了</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</blockquote>
</li>
<li><p>模版的<strong>默认参数</strong></p>
<p>  新标准中可以为<strong>函数模板和类模板</strong>提供默认参数：比如<code>std::vector</code>的模板参数<code>allocator</code>就有默认值</p>
  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> F=std::less&lt;T&gt;&gt;</span><br><span class="line"><span class="type">int</span> <span class="built_in">compare</span>(<span class="type">const</span> T&amp; v1, <span class="type">const</span> T&amp; v2, F f=<span class="built_in">F</span>())&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">f</span>(v1, v2)) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">f</span>(v2, v2)) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">int</span> <span class="title">compare_int</span><span class="params">(<span class="type">const</span> <span class="type">int</span>&amp; a, <span class="type">const</span> <span class="type">int</span>&amp; b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (a &lt; b) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">if</span> (b &lt; a) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">auto</span> func = [](<span class="type">const</span> <span class="type">int</span>&amp; a, <span class="type">const</span> <span class="type">int</span>&amp; b)&#123; </span><br><span class="line">    <span class="keyword">if</span> (a &lt; b) <span class="keyword">return</span> <span class="number">-1</span>; </span><br><span class="line">    <span class="keyword">if</span> (b &lt; a) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// use default parameter</span></span><br><span class="line"><span class="keyword">auto</span> v = <span class="built_in">compare</span>(<span class="number">1.0</span>, <span class="number">1.0</span>);</span><br><span class="line"><span class="comment">// pass third parameter explicitly</span></span><br><span class="line"><span class="keyword">auto</span> v1 = <span class="built_in">compare</span>(<span class="number">1</span>, <span class="number">1</span>, compare_int);</span><br><span class="line"><span class="keyword">auto</span> v2 = <span class="built_in">compare</span>(<span class="number">1</span>, <span class="number">2</span>, func);</span><br></pre></td></tr></table></figure>
</li>
<li><p>函数模版</p>
<p>一个函数模版就像是一个公式，可以用来<strong>生成针对特定类型的函数版本</strong></p>
<p>函数模版是可以声明成为<code>inline</code>和<code>constexpr</code>的，如同普通函数一样，这些<strong>关键字出现在参数列表之后</strong></p>
<p><strong>编译器可以为函数模版推断参数</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">compare</span><span class="params">(<span class="type">const</span> T&amp; v1, <span class="type">const</span> T&amp; v2)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (std::<span class="built_in">less</span>&lt;T&gt;(v1, v2))&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (std::<span class="built_in">less</span>&lt;T&gt;(v2, v2))&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">compare</span>(<span class="number">1.1</span>, <span class="number">2.2</span>);     <span class="comment">// auto deduced to T is double</span></span><br><span class="line"><span class="built_in">compare</span>(<span class="number">1L</span>, <span class="number">1L</span>);       <span class="comment">// auto deduced to T is long int</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>类模版：</p>
<p>类模版是用来生成一系列类的；<strong>类模版的名字不是类型名</strong>，类模版是用来实例化类型，而<strong>一个实例化的类型总是包含模版参数的</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Blob</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">typedef</span> T value_type;</span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">typename</span> std::vector&lt;T&gt;::size_type size_type;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">Blob</span>())&#123;std::cout &lt;&lt; <span class="string">&quot;Ctor of BlobA&quot;</span> &lt;&lt; std::endl;&#125;</span><br><span class="line">    <span class="built_in">Blob</span>(std::initializer_list&lt;T&gt; il);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// inside class scope, Blob equal to Blob&lt;T&gt;</span></span><br><span class="line">    <span class="comment">//Blob&lt;T&gt;()&#123;std::cout &lt;&lt; &quot;Ctor of BlobA&quot; &lt;&lt; std::endl;&#125;</span></span><br><span class="line">    <span class="comment">//Blob&lt;T&gt;(std::initializer_list&lt;T&gt; il);</span></span><br><span class="line"></span><br><span class="line">    <span class="function">size_type <span class="title">size</span><span class="params">()</span> <span class="type">const</span> </span>&#123;<span class="keyword">return</span> data-&gt;<span class="built_in">size</span>();&#125;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">empty</span><span class="params">()</span> <span class="type">const</span></span>&#123;<span class="keyword">return</span> data-&gt;<span class="built_in">empty</span>();&#125;</span><br><span class="line">    T&amp; <span class="keyword">operator</span>[](size_type i);</span><br><span class="line">    <span class="function">T&amp; <span class="title">back</span><span class="params">()</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::shared_ptr&lt;std::vector&lt;T&gt;&gt; data;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">check</span><span class="params">(size_type i, <span class="type">const</span> std::string&amp;msg)</span> <span class="type">const</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Blob&lt;<span class="type">int</span>&gt; blob;</span><br></pre></td></tr></table></figure>

<p><strong>为了使用类模版，必须在模版名后的尖括号内提供多余信息，即模版实参列表(until C++17)</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Blob&lt;<span class="type">int</span>&gt; int_b;</span><br><span class="line">Blob&lt;<span class="type">float</span>&gt; float_b;</span><br></pre></td></tr></table></figure>

<p>与其他类相同，我们可以在类<strong>模版的内部或者类模版的外部</strong>为其定义成员函数，定义在内部的成员函数默认<code>inline</code></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">Blob&lt;T&gt;::<span class="built_in">Blob</span>()&#123;</span><br><span class="line">    <span class="comment">// init ctor</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="type">void</span> Blob&lt;T&gt;::<span class="built_in">check</span>(size_type i, <span class="type">const</span> std::string&amp; msg) <span class="type">const</span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (i &gt;= data-&gt;<span class="built_in">size</span>())&#123;</span><br><span class="line">        <span class="keyword">throw</span> std::<span class="built_in">out_of_range</span>(msg);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>默认情况下，一个类模版的成员<strong>只有当程序用到它的时候才进行实例化</strong>；如果一个成员没有被使用，则不会实例化</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// only instance Blob&lt;int&gt; and 3 corresponding function members: ctor, size, operator[]</span></span><br><span class="line">Blob&lt;<span class="type">int</span>&gt; squares = &#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>&#125;;            <span class="comment">// call Blob(std::initializer_list&lt;T&gt; il);</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">size_t</span> i=<span class="number">0</span>; i&lt;squares.<span class="built_in">size</span>(); i++)&#123;        <span class="comment">// call size_type size() const;</span></span><br><span class="line">    squares[i] i*i;                             <span class="comment">// call T&amp; operator[](size_type i);</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在模版类的作用域内，可以简化模版类名的使用，<strong>我们可以直接使用模版名而不需要加模版参数</strong>；但是在类的作用域外，还是必须老老实实<code>模版名&lt;参数名&gt;</code>，直到遇到类名，类名之后才进入<strong>类的作用域</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">BlobPtr&lt;T&gt; BlobPtr&lt;T&gt;::<span class="keyword">operator</span>++(<span class="type">int</span>)&#123;</span><br><span class="line">    BlobPtr ret = *<span class="keyword">this</span>;</span><br><span class="line">    ++*<span class="keyword">this</span>;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;    </span><br></pre></td></tr></table></figure>

<p>类模版的别名：虽然没法<code>typedef</code>引用一个模版<code>Blob&lt;T&gt;</code>，但是<strong>新标准允许我们使用<code>using</code>为类模版指定别名</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="keyword">using</span> Pair = std::pair&lt;T, T&gt;;</span><br><span class="line">Pair&lt;<span class="type">int</span>&gt; i_twin;       <span class="comment">// equal to std::pair&lt;int, int&gt;</span></span><br><span class="line">Pair&lt;<span class="type">double</span>&gt; d_twin;    <span class="comment">// equal to std::pair&lt;double, double&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="keyword">using</span> UnsignedPair = std::pair&lt;T, <span class="type">unsigned</span> <span class="type">int</span>&gt;;</span><br><span class="line">UnsignedPair&lt;<span class="type">int</span>&gt; a;    <span class="comment">// equal to std::pair&lt;int, unsigned int&gt;;</span></span><br><span class="line">UnsignedPair&lt;<span class="type">float</span>&gt; a;  <span class="comment">// equal to std::pair&lt;float, unsigned int&gt;;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>类模版的静态成员</p>
<ul>
<li><p><strong>每个类模版的实例都有自己<code>static</code>成员类型，所有的类模版的实例的对象们共享一个静态变量</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; </span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Foo</span>&#123;</span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> val;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Foo&lt;std::string&gt; fs1, fs2;   <span class="comment">// share same static member </span></span><br><span class="line">Foo&lt;<span class="type">int</span>&gt; fi1, fi2, fi3;      <span class="comment">// share same static member but different from fs1&#x27;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>每个静态数据成员都<strong>需要在类外进行定义</strong>，而且有且仅有一个定义；<strong>与定义模版的成员函数类似，将<code>static</code>数据成员也定义为模版</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// this is not a function or class template</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="type">int</span> Foo::val = <span class="number">0</span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>与非模版类的静态成员类似，<strong>我们可以通过类类型的对象和域访问符来访问类模版的静态变量</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Foo&lt;<span class="type">int</span>&gt; fi;</span><br><span class="line">fi.val = <span class="number">10</span>;    </span><br><span class="line">Foo&lt;<span class="type">int</span>&gt;::val = <span class="number">20</span>;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>类模版与<strong>友元</strong></p>
<p>当一个类包含一个友元声明，类和友元各自是否是模版是不相关的</p>
<ul>
<li><p><strong>一对一</strong>(<em><strong>one-to-one</strong></em>)友元关系：即<strong>类模版的特定实例与其友元的关系</strong></p>
  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// one-to-one</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="keyword">class</span> <span class="title class_">BlobStr</span>;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="keyword">class</span> <span class="title class_">Blob</span>;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; </span><br><span class="line"><span class="type">bool</span> <span class="keyword">operator</span>==(<span class="type">const</span> Blob&lt;T&gt;&amp; lhs, <span class="type">const</span> Blob&lt;T&gt;&amp; rhs)&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;equal: &quot;</span> &lt;&lt; (lhs.val == rhs.val) &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// template parameter is T</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="keyword">class</span> <span class="title class_">Blob</span>&#123;   </span><br><span class="line">    <span class="comment">// 每个Blob实例将访问权限授予用相同类型实例化的operator==运算符</span></span><br><span class="line">    <span class="comment">// template parameter is also T</span></span><br><span class="line">    <span class="keyword">friend</span> <span class="type">bool</span> <span class="keyword">operator</span>==&lt;T&gt;(<span class="type">const</span> Blob&lt;T&gt;&amp;, <span class="type">const</span> Blob&lt;T&gt;&amp;); </span><br><span class="line">    <span class="type">int</span> val = <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>一对多</strong>(<em><strong>one-to-many</strong></em>) 友元关系：即<strong>一个类</strong>可以与<strong>另一个类模版的任何实例</strong>构成友元关系</p>
  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// one-to-many</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="keyword">class</span> <span class="title class_">Pal</span>;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">C</span> &#123;</span><br><span class="line">    <span class="keyword">friend</span> <span class="keyword">class</span> <span class="title class_">Pal</span>&lt;C&gt;;   <span class="comment">// 用C实例化的Pal是C的友元</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>多对多</strong>(<em><strong>many-to-many</strong></em>) 友元关系：即<strong>一个类模版的任何实例</strong>可以与<strong>另一个类模版的任何实例</strong>构成友元关系</p>
  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// many-to-many</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="keyword">class</span> <span class="title class_">C2</span>&#123;  <span class="comment">// template parameter is T, different from X</span></span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> X&gt; <span class="keyword">friend</span> <span class="keyword">class</span> <span class="title class_">Pal2</span>;  <span class="comment">// Pal2的所有实例都是C2的每个实例的友元,</span></span><br><span class="line">                                              <span class="comment">// 这种情况无需前置声明Pal2</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
<li><p>可以<strong>令模版自己的类型参数为友元</strong></p>
  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Bar</span>&#123;</span><br><span class="line">      <span class="keyword">friend</span> T;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>成员模板(<em>member template</em>)</p>
<p>利用<strong>函数模板可以自动推导模板的类型</strong>，一个类（包含模板类）可以包含<strong>本身是模板的成员函数</strong>，这种成员叫做<strong>成员模板</strong></p>
<ul>
<li><p><strong>普通类</strong>的成员模板</p>
  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">DebugDeleter</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">DebugDeleter</span>()=<span class="keyword">default</span>;</span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="function"><span class="type">void</span> <span class="title">operator</span><span class="params">(T* p)</span></span>&#123;<span class="keyword">delete</span> p;&#125; <span class="comment">// member template</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// instance</span></span><br><span class="line"><span class="keyword">auto</span> deleter = <span class="built_in">DebugDeleter</span>();</span><br><span class="line"><span class="type">double</span> *p = <span class="keyword">new</span> <span class="type">double</span>;</span><br><span class="line"><span class="built_in">deleter</span>(p);  <span class="comment">// call void operator()(double *);</span></span><br><span class="line"><span class="type">int</span> *i = <span class="keyword">new</span> <span class="type">int</span>;</span><br><span class="line"><span class="built_in">deleter</span>(i);  <span class="comment">// call void operator()(int *);</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// call void operator()(std::string)</span></span><br><span class="line">std::<span class="built_in">unique_ptr</span>&lt;std::string, DebugDelete&gt;(<span class="keyword">new</span> std::string, <span class="built_in">DebugDelete</span>());</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>模版类</strong>的成员模版</p>
  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Blob</span> &#123;</span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> It&gt; <span class="built_in">Blob</span>(It begin, It end)&#123;</span><br><span class="line">        <span class="comment">// copy</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// define outside class template</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> It&gt;</span><br><span class="line">Blob&lt;T&gt;::<span class="built_in">Blob</span>(It begin, It end)&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// instance</span></span><br><span class="line"><span class="type">int</span> a1[] = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>&#125;;</span><br><span class="line">std::vector&lt;<span class="type">long</span>&gt; a2 = &#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;</span><br><span class="line"><span class="comment">// call Blob&lt;int&gt;(int* begin, int* end);</span></span><br><span class="line"><span class="function">Blob&lt;<span class="type">int</span>&gt; <span class="title">b</span><span class="params">(a1, a1+<span class="number">5</span>)</span></span>;                            </span><br><span class="line"><span class="comment">// calll Blob&lt;long&gt;(std::vector&lt;long&gt;::iterator, std::vector&lt;long&gt;::iterator)</span></span><br><span class="line"><span class="function">Blob&lt;<span class="type">long</span>&gt; <span class="title">c</span><span class="params">(a2.begin(), a2.end())</span></span>;    </span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<h3 id="Template-Compilation"><a href="#Template-Compilation" class="headerlink" title="Template Compilation"></a>Template Compilation</h3><ul>
<li><p>模板不支持分离式编译</p>
<blockquote>
<p><strong>如果分离编译会发生什么？</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"> &gt;<span class="comment">// test.h</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T1, <span class="keyword">class</span> T2&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(T1 t1, T2 t2)</span></span>;</span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"> &gt;<span class="comment">// test.cpp</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;test.h&quot;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T1, <span class="keyword">class</span> T2&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(T1 t1, T2 t2)</span> </span>&#123;</span><br><span class="line"> cout&lt;&lt;t1&lt;&lt;t2&lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"> &gt;<span class="comment">// main.cpp</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;test.h&quot;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"> <span class="function">string <span class="title">str</span><span class="params">(<span class="string">&quot;downey&quot;</span>)</span></span>;</span><br><span class="line"> <span class="type">int</span> i=<span class="number">5</span>;</span><br><span class="line">    <span class="built_in">func</span>(str,<span class="number">5</span>);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p>标准的分离编译模式：在<code>test.h</code>中声明<code>func()</code>,在<code>test.cpp</code>中定义<code>func()</code>实现，在<code>main.cpp</code>中包含<code>test.h</code>头文件并应用<code>func()</code>。<strong>编译运行会报错</strong>，<strong>可以见得分离编译对于模版是行不通的</strong>。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">g++ test.cpp test.h main.cpp -o <span class="built_in">test</span></span></span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"> &gt;/tmp/ccqLWRwf.o: In function `main<span class="number">&#x27;</span>:</span><br><span class="line">main.cpp:(.text+<span class="number">0x6c</span>): undefined reference to `<span class="type">void</span> func&lt;std::__cxx11::basic_string&lt;<span class="type">char</span>, std::char_traits&lt;<span class="type">char</span>&gt;, std::allocator&lt;<span class="type">char</span>&gt; &gt;, <span class="type">int</span>&gt;(std::__cxx11::basic_string&lt;<span class="type">char</span>, std::char_traits&lt;<span class="type">char</span>&gt;, std::allocator&lt;<span class="type">char</span>&gt; &gt;, <span class="type">int</span>)&#x27;</span><br><span class="line">collect2: error: ld returned <span class="number">1</span> exit status  </span><br></pre></td></tr></table></figure>

<p>reference：<a target="_blank" rel="noopener" href="https://blog.csdn.net/c_base_jin/article/details/72861789">https://blog.csdn.net/c_base_jin/article/details/72861789</a></p>
</blockquote>
</li>
<li><p>模版的编译</p>
<p>模板<strong>只有在实例化的时候才会生成代码</strong>，一般编译模版分三步：</p>
<ul>
<li><p>第一阶段是<strong>编译模板本身</strong>。编译器没有太多可以检查，一般会做<strong>语法检查</strong>，比如忘记分号、变量名不存在等错误；</p>
</li>
<li><p>第二阶段是<strong>遇到模板的声明</strong>时，编译器也没有很多可以检查的，一般检查<strong>参数数目、类型</strong>是不是正确等；</p>
</li>
<li><p>第三阶段是<strong>模板实例化</strong>时，这个时候编译器才<strong>正式生成代码</strong>，发现<strong>类型相关错误</strong>，以及最后<strong>链接时可能出的错误</strong>；</p>
</li>
</ul>
<blockquote>
<p>如果只用<code>test.cpp</code>和<code>test.h</code>文件来编译出目标文件会发生什么？</p>
<p>首先，这种方式是可行的，用<code>g++</code>提供的<code>-C</code>参数对目标文件<strong>只编译不链接</strong>：</p>
<figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">g++ -C <span class="keyword">test</span><span class="number">.</span>cpp <span class="keyword">test</span><span class="number">.</span>h -o <span class="keyword">test</span><span class="number">.</span>o</span><br></pre></td></tr></table></figure>

<p>生成的<code>test.o</code>文件，用linux下的 <code>nm</code> 命令查看目标文件符号表：</p>
<figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nm -C -n <span class="keyword">test</span><span class="number">.</span>o</span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">U __cxa_atexit</span><br><span class="line">U __dso_handle</span><br><span class="line">U std::ios_base::Init::<span class="built_in">Init</span>()</span><br><span class="line">U std::ios_base::Init::~<span class="built_in">Init</span>()</span><br><span class="line"><span class="number">0000000000000000</span> t __static_initialization_and_destruction_0(<span class="type">int</span>, <span class="type">int</span>)</span><br><span class="line"><span class="number">0000000000000000</span> b std::__ioinit</span><br><span class="line"><span class="number">000000000000003</span>e t _GLOBAL__sub_I_test.cpp  </span><br></pre></td></tr></table></figure>

<p>丝毫看不到<code>func()</code>的影子，也就是说编译出的二进制文件中根本没有为<code>func()</code>分配内存空间，这是为什么呢？</p>
<p>答案是：<strong>模板只有在使用的时候才进行实例化</strong></p>
<p>通俗地说，用户写一个模板定义，模板本身提供任何数据类型的支持，而编译器在编译出的<strong>目标文件中只支持确定的类型</strong>例如<code>func(int,int)</code>,<code>func(string char)</code>，而不能支持<code>func(模板类，模板类...)</code>（<em><strong>注意模板是C++的特性而非编译器的特性</strong></em>）。</p>
<p><strong>编译器在编译的时候根本不知道用户要传入什么样的参数，所以无法确定模板的实例，所以编译器只能等到用户使用此模板的时候才能进行实例化，才能确定模板的具体类型，从而为其分配内存空间，像上述例子中，模板没有实例化，编译器也就不会为模板分配内存空间</strong>。</p>
<p>为什么同时编译<code>test.cpp`` test.h</code> <code>main.cpp</code>的例子中，模板在main函数中有进行实例化，还是会提示无定义行为呢？</p>
<p>事实上编译器是对所有的<code>.cpp</code>文件分开编译的：</p>
<p><code>main.cpp</code>依赖<code>test.h</code>,就会将<code>main.cpp</code>和<code>test.h</code>编译成<code>main.o</code>目标文件</p>
<p><code>test.cpp</code>依赖<code>test.h</code>，将<code>test.cpp</code>和<code>test.h</code>编译成<code>test.o</code>目标文件</p>
<p>然后链接器将<code>main.o</code>和<code>test.o</code>以及一些标准库链接成可执行文件。</p>
<p>但是由上的分析得知，在编译<code>test.o</code>文件过程中编译器并没有将<code>func()</code>实例化，所以<code>test.o</code>中也就是没有<code>func()</code>的定义，所以在链接的时候出现未定义行为。</p>
<p>如果在<code>.cpp</code>文件中将模板实例化呢？</p>
<p>在以上的示例中，我在<code>test.cpp</code>中添加一个<code>func()</code>的调用，<code>main.cpp</code>保持不变：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">func1</span><span class="params">(string str,<span class="type">int</span> val)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">func</span>(str,val);       <span class="comment">//将func实例化</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这时候再进行编译竟然可以编译通过，而且键入命令可以正常运行，这个例子说明只要我在定义文件中进行了实例化，编译器就会为这个模板分配内存空间。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">g++ test.cpp test.h main.cpp -o <span class="built_in">test</span></span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./test</span><br></pre></td></tr></table></figure>

<p>reference：<a target="_blank" rel="noopener" href="https://blog.csdn.net/c_base_jin/article/details/72861789">https://blog.csdn.net/c_base_jin/article/details/72861789</a></p>
</blockquote>
</li>
<li><p>解决模板这种编译上的特性导致的问题</p>
<blockquote>
<ul>
<li>解决方案1：<strong>提前实例化模板</strong></li>
</ul>
<p>一种分离编译的解决方案，<strong>在模板定义文件中将所有要用到的模板函数都进行实例化</strong>，不过说实话，这很扯蛋，而且完全不符合程序的美学。设计泛型接口本身就是为了多态，并不需要知道调用者以什么方式调用，这样实现的话接口设计者就得知道调用者的所有调用方式！但事实上是确实可以这么做。</p>
<ul>
<li>解决方案2：<strong>定义实现全部放在同一个.h头文件中</strong></li>
</ul>
<p>为什么这样又可以呢？当某个<code>.cpp</code>文件用到某个模板时，包含了相应的头文件，而头文件中同时由模板的定义和声明，在<code>.cpp</code>文件中使用就相当于对这个模板进行了实例化(.<code>cpp</code>文件依赖<code>.h</code>文件编译成<code>.o</code>文件，<code>.cpp</code>文件中实例化，<code>.h</code>文件中进行定义和声明)，这样就可以使用模板了。</p>
<p>这也是常见的做法，STL就是这样实现的，遗憾的是，这违背了分离编译的思想。</p>
<p>reference：<a target="_blank" rel="noopener" href="https://blog.csdn.net/c_base_jin/article/details/72861789">https://blog.csdn.net/c_base_jin/article/details/72861789</a></p>
</blockquote>
</li>
<li><p><strong>smart</strong>技术</p>
<p>由于在模板实例化出现的地方都会导致生成实例化类的定义代码，这样不同的源文件用了多少模板的实例化，就会生成多少份实例化的定义，这也意味着多个独立编译的源文件很可能使用了相同的定义代码。如果不对这些链接去重，在链接的时候一定会出现<strong>重复定义</strong>(<em>duplicate symbols</em>)的问题；</p>
<blockquote>
<p>不同的编译器，其对模板的编译和链接技术也会有不同，其中一个常用的技术称之为smart，其基本原理如下：</p>
<ol>
<li>模板编译时，以每个cpp文件为编译单位，实例化该文件中的函数模板和类模板</li>
<li><strong>链接器在链接每个目标文件时，会检测是否存在相同的实例；有存在相同的实例版本，则删除一个重复的实例，保证模板实例化没有重复存在</strong>。</li>
</ol>
<p>比如我们有一个程序，包含<code>A.cpp</code>和<code>B.cpp</code>，它们都调用了<code>CThree</code>模板类，在<code>A.cpp</code>中定义了<code>int</code>和<code>double</code>型的模板类，在<code>B.cpp</code>中定义了<code>int</code>和<code>double</code>型的模板类；在编译器编译时<code>.cpp</code>文件为编译基础，生成<code>A.o</code>和<code>B.o</code>目标文件，即使<code>A.o</code>和<code>B.o</code>存在重复的实例版本，但是在链接时，链接器会把所有冗余的模板实例代码删除，保证exec中的实例都是唯一的。</p>
<p>reference：<a target="_blank" rel="noopener" href="https://blog.csdn.net/c_base_jin/article/details/72861789">https://blog.csdn.net/c_base_jin/article/details/72861789</a></p>
</blockquote>
</li>
<li><p>进一步控制模板的实例化</p>
<p>在一些大系统中，对<strong>多个文件中实例化相同的模版的额外开销可能非常大</strong>，相当于每个实例化都要编译一遍</p>
<p>新标准中，可以通过<strong>显式实例化</strong>(<em><strong>explicit instantiation</strong></em>)规避这种开销</p>
<ul>
<li>当编译器遇到<code>extren template</code>的声明时，不会在本文件(编译单元, <em>compile unit</em>)生成实例化代码</li>
<li><strong>extern声明必须出现在任何使用此实例化代码之前</strong>，否则编译器会自动对其实例化</li>
<li>对于每个实例化声明，程序的某个位置一定要有其<strong>显示的实例化定义</strong></li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// declaration 是一个类或者函数的声明，即模板的实例化，模板的参数都替换位了模板实参</span></span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">template</span> declaration;   <span class="comment">// 显式实例化声明</span></span><br><span class="line"><span class="keyword">template</span> declaration;          <span class="comment">// 显式实例化定义</span></span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// application.cc</span></span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">template</span> <span class="keyword">class</span> <span class="title class_">Blob</span>&lt;std::string&gt;;</span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">template</span> <span class="keyword">class</span> <span class="title class_">Blob</span>&lt;<span class="type">int</span>&gt;;</span><br><span class="line"><span class="function"><span class="keyword">extern</span> <span class="keyword">template</span> <span class="type">int</span> <span class="title">compare</span><span class="params">(<span class="type">const</span> <span class="type">int</span>&amp;, <span class="type">const</span> <span class="type">int</span>&amp;)</span></span>;</span><br><span class="line"></span><br><span class="line">Blob&lt;std::string&gt; sa1, sa2;           <span class="comment">// not generate code</span></span><br><span class="line">Blob&lt;<span class="type">int</span>&gt; a = &#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>&#125;;        <span class="comment">// not generate code</span></span><br><span class="line"><span class="type">int</span> i = <span class="built_in">compare</span>(a[<span class="number">0</span>], a[<span class="number">1</span>]);          <span class="comment">// not generate code</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// template_builder.cc</span></span><br><span class="line"><span class="keyword">template</span> <span class="keyword">class</span> <span class="title class_">Blob</span>&lt;std::string&gt;;     <span class="comment">// explicitly instance template and generate code</span></span><br><span class="line"><span class="keyword">template</span> <span class="keyword">class</span> <span class="title class_">Blob</span>&lt;<span class="type">int</span>&gt;;</span><br><span class="line"><span class="function"><span class="keyword">template</span> <span class="type">int</span> <span class="title">compare</span><span class="params">(<span class="type">const</span> <span class="type">int</span>&amp;, <span class="type">const</span> <span class="type">int</span>&amp;)</span></span>;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="Template-Argument-Deduction"><a href="#Template-Argument-Deduction" class="headerlink" title="Template Argument Deduction"></a>Template Argument Deduction</h3><ul>
<li><p>模板参数类型推断<strong>支持的类型转换</strong></p>
<ul>
<li><p>顶层const无论在实参还是形参中，都会被忽略</p>
  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="function">T <span class="title">fobj</span><span class="params">(T, T)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function">std::string <span class="title">s1</span><span class="params">(<span class="string">&quot;hello&quot;</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="type">const</span> std::string <span class="title">s2</span><span class="params">(<span class="string">&quot;hi&quot;</span>)</span></span>;</span><br><span class="line"><span class="built_in">fobj</span>(s1, s2);  <span class="comment">// 顶层const被忽略</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>可以将一个非底层const的引用(或指针)的实参传递给一个底层const的引用(或指针)的形参</p>
  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> <span class="type">const</span> T&amp;&gt; <span class="function">T <span class="title">fref</span><span class="params">(<span class="type">const</span> T&amp;, <span class="type">const</span> T&amp;)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function">std::string <span class="title">s1</span><span class="params">(<span class="string">&quot;hello&quot;</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="type">const</span> std::string <span class="title">s2</span><span class="params">(<span class="string">&quot;hi&quot;</span>)</span></span>;</span><br><span class="line"><span class="built_in">fref</span>(s1, s2);  <span class="comment">// 可以将s1转换为const</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>如果函数的形参有数组或者函数且都不是引用类型，可以对<strong>数组或者函数</strong>的实参<strong>应用正常的指针类型转换</strong>；数组转换为指向其首元素的指针，函数转换为函数类型的指针</p>
  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a[<span class="number">10</span>], b[<span class="number">40</span>];</span><br><span class="line"><span class="built_in">fobj</span>(a, b);   <span class="comment">// valid, convert array to pointer int*</span></span><br><span class="line"><span class="built_in">fref</span>(a, b);   <span class="comment">// invalid, a b have different array size, so the type diffs</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>其他的所谓隐式的类型转换在模版参数推导这里都不支持</strong></p>
<ul>
<li>算术转换</li>
<li>派生类到基类的转换</li>
<li>用户定义的转换，比如构造函数implicit的转换、类的类型限定符等</li>
</ul>
  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> F=std::less&lt;T&gt;&gt;</span><br><span class="line"><span class="type">int</span> <span class="built_in">compareF</span>(<span class="type">const</span> T&amp; v1, <span class="type">const</span> T&amp; v2, F f=<span class="built_in">F</span>())；</span><br><span class="line"></span><br><span class="line"><span class="type">long</span> lng = <span class="number">1</span>;</span><br><span class="line"><span class="built_in">compare</span>(lng, <span class="number">1</span>);  <span class="comment">// invalid, compare(long, int), algorithm conversion not supported</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>如果函数参数类型<strong>不是模版参数</strong>，则在函数匹配的时候对<strong>实参进行正常的类型转换</strong></p>
  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; </span></span><br><span class="line"><span class="function">ostream&amp; <span class="title">print</span><span class="params">(ostream &amp;os, <span class="type">const</span> T&amp; obj)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(std::cout, <span class="number">42</span>);        <span class="comment">// instance print(ostream&amp;, int);</span></span><br><span class="line"><span class="function">ofstream <span class="title">f</span><span class="params">(<span class="string">&quot;output.txt&quot;</span>)</span></span>;</span><br><span class="line"><span class="built_in">print</span>(f, <span class="number">42</span>);                <span class="comment">// convert ofstream to ostream implicitly</span></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>函数模版显式实参</p>
<p>  某些情况下，编译器<strong>无法推断出函数实参的类型</strong>；另外一些情况下，我们希望允许<strong>用户控制模版实例化</strong>；特别是在函数返回值的类型和模版参数类型都不同的时候最为有用</p>
<ul>
<li><p>显式模版实参按照<strong>从左到右的顺序</strong>与对应的模板参数匹配</p>
</li>
<li><p>显式指定的实参<strong>可以正常隐式类型转换</strong></p>
  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T1, <span class="keyword">typename</span> T2, <span class="keyword">typename</span> T3&gt;</span><br><span class="line"><span class="function">T1 <span class="title">sum</span><span class="params">(T2, T3)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="type">long</span> lng = <span class="number">10</span>;</span><br><span class="line"><span class="built_in">sum</span>&lt;<span class="type">long</span> <span class="type">long</span>&gt;(<span class="number">12</span>, lng);          <span class="comment">// instance long long sum(int, long);</span></span><br><span class="line"><span class="built_in">sum</span>&lt;<span class="type">long</span>, <span class="type">float</span>&gt;(<span class="number">12</span>, lng);        <span class="comment">// instance long sum(float, long);</span></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>尾置返回类型</p>
<ul>
<li><p>比如模板参数是迭代器类型，此时并不知道模板函数返回的准确类型，但知道所需类型是所处理的序列的元素类型；定义此函数，如果直接把返回类型作为模板参数传进去也不是不行，但是会给用户带来负担，此时使用尾置返回就很方便</p>
  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> It&gt;</span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">fcn</span><span class="params">(It beg, It end)</span> -&gt; <span class="keyword">decltype</span>&lt;*beg&gt;</span>&#123;</span><br><span class="line">    <span class="comment">// do something</span></span><br><span class="line">    <span class="keyword">return</span> *beg;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>有时候无法直接获取所需要的类型，比如<code>decltype</code>返回的是引用，但是我们希望返回类型的值；此时可以使用标准库的<strong>类型转换(type transformation)</strong></p>
<p>  这些类型转换的模版的工作方式都一样，<strong>每个模板都有一个名为<code>type</code>的<code>public</code>成员，表示一个类型</strong></p>
<ul>
<li><p><code>std::remove_reference</code>, <code>std::add_lvalue_reference</code>, <code>std::add_rvalue_reference</code>, </p>
<p>  <code>std::add_pointer</code>, <code>std::remove_pointer</code></p>
</li>
<li><p><code>std::add_const</code></p>
</li>
<li><p><code>std::make_signed</code>, <code>std::make_unsigned</code></p>
</li>
</ul>
  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;type_trait&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> It&gt;</span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">fcn</span><span class="params">(It beg, It end)</span> -&gt; <span class="keyword">typename</span> std::remove_reference&lt;<span class="keyword">decltype</span>&lt;*beg&gt;&gt;::type</span>&#123;</span><br><span class="line">    <span class="comment">// do something</span></span><br><span class="line">    <span class="keyword">return</span> *beg;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>std::remove_reference</code>的STL实现</p>
  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// remove_reference: gcc/libstdc++-v3/include/std/type_traits</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> _Tp&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">remove_reference</span></span><br><span class="line">&#123; <span class="keyword">typedef</span> _Tp   type; &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> _Tp&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">remove_reference</span>&lt;_Tp&amp;&gt;</span><br><span class="line">&#123; <span class="keyword">typedef</span> _Tp   type; &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> _Tp&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">remove_reference</span>&lt;_Tp&amp;&amp;&gt;</span><br><span class="line">&#123; <span class="keyword">typedef</span> _Tp   type; &#125;;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>使用函数模板初始化函数指针的类型推断</p>
<ul>
<li><p>可以使用一个<strong>函数模板</strong>来初始化或者赋值一个<strong>函数指针</strong>，编译器通过<strong>函数指针的参数类型来推断模板实参类型</strong></p>
  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">compare</span><span class="params">(<span class="type">const</span> T&amp;, <span class="type">const</span> T&amp;)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">int</span> (*fp1)(<span class="type">const</span> <span class="type">int</span>&amp;, <span class="type">const</span> <span class="type">int</span>&amp;) = compare;  <span class="comment">// instance int compare(const int&amp;, const int&amp;);</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>当函数模版当作函数的函数指针类型的参数的时候，程序上下文需<strong>确保模板参数能唯一确定其类型</strong></p>
  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">int</span>(*)(<span class="type">const</span> std::string&amp;, <span class="type">const</span> std::string*))</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">int</span>(*)(<span class="type">const</span> <span class="type">int</span>&amp;, <span class="type">const</span> <span class="type">int</span>&amp;))</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">func</span>(compare);   <span class="comment">// invalid, compile can not determinate whether T is std::string or int</span></span><br></pre></td></tr></table></figure>

<p>  此时可以显式指定参数类型：</p>
  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">func</span>(compare&lt;<span class="type">int</span>&gt;);                <span class="comment">// valid</span></span><br><span class="line"><span class="built_in">func</span>(compare&lt;std::string&gt;);        <span class="comment">// valid</span></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><strong>左值引用形参</strong>的实参推断</p>
<ul>
<li><p>普通左值引用(<em>lvalue reference</em>)</p>
<p><strong>可以传递给形参一个左值；如果实参有const，则实参被推断为const；也可以传递右值引用</strong>(引用折叠)</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="function"><span class="type">void</span> <span class="title">f1</span><span class="params">(T&amp;)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> i = <span class="number">10</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> ci = <span class="number">15</span>;</span><br><span class="line"><span class="built_in">f1</span>(i);       <span class="comment">// T is int</span></span><br><span class="line"><span class="built_in">f1</span>(ci);      <span class="comment">// T is const int</span></span><br><span class="line"><span class="built_in">f1</span>(<span class="number">5</span>);       <span class="comment">// error, can not bind a rvalue to a non-const lvalue-reference</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>常量左值引用(<em>const lvalue-reference</em>)</p>
<p><strong>可以传递任何参数（任意左值、右值）；const已经是形参的一部分，所以实参类型不会被推断为const</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="function"><span class="type">void</span> <span class="title">f2</span><span class="params">(<span class="type">const</span> T&amp;)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> i = <span class="number">10</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> ci = <span class="number">15</span>;</span><br><span class="line"><span class="built_in">f2</span>(i);       <span class="comment">// T is int</span></span><br><span class="line"><span class="built_in">f2</span>(ci);      <span class="comment">// T is int, not const int, because parameter is const already</span></span><br><span class="line"><span class="built_in">f2</span>(<span class="number">5</span>);       <span class="comment">// T is int, pass a rvalue to const lvalue-reference</span></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><strong>右值引用形参</strong>的实参推断</p>
<p> 正常绑定规则告诉我们只可以<strong>传递一个右值给右值引用形参</strong>，推导过程类似普通左值引用</p>
 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="function"><span class="type">void</span> <span class="title">f3</span><span class="params">(T&amp;&amp;)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">f3</span>(<span class="number">42</span>);   <span class="comment">// T is int</span></span><br></pre></td></tr></table></figure>
<p> 通常而言，是<strong>不可以将左值绑定给右值引用</strong>，但是C++语言在正常的绑定规则之外<strong>定义了两个例外</strong>：</p>
<p> 第一：C++规定可以将<strong>左值类型的实参</strong>绑定到一个<strong>模版的右值引用类型</strong>（<code>T&amp;&amp;</code>）的形参上</p>
 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="function"><span class="type">void</span> <span class="title">f3</span><span class="params">(T&amp;&amp;)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> i = <span class="number">10</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> ci = <span class="number">15</span>;</span><br><span class="line"><span class="built_in">f3</span>(<span class="number">42</span>);        <span class="comment">// T is int&amp;, similar to void f3&lt;int&amp;&gt;(int&amp; &amp;&amp;), via reference folding, </span></span><br><span class="line">               <span class="comment">// convert to int&amp;, argument like a rvalue-reference to a lvalue-reference</span></span><br><span class="line"><span class="built_in">f3</span>(ci);        <span class="comment">// T is const int&amp;</span></span><br></pre></td></tr></table></figure>
<p> 第二： <strong>引用折叠</strong>(<em>Reference Collapsing</em>)：我们可以<strong>间接</strong>创建了<strong>一个引用的引用</strong>，此时这些引用会发生<strong>引用折叠</strong></p>
<ul>
<li><p>通常我们不能直接定义一个引用的引用，但是<strong>可以通过类型别名(<code>typedef</code>, <code>using</code>)以及模版参数间接定义</strong></p>
</li>
<li><p>引用折叠<strong>只能应用于间接创建的引用的引用，比如类型别名和模版参数</strong>; 参数折叠<strong>不一定都发生在模版函数的参数</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;type_trait&gt;</span></span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test_func</span><span class="params">(T &amp;&amp;)</span></span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;int&amp; &amp;&amp; is lvalue: &quot;</span> &lt;&lt; std::is_lvalue_reference&lt;T&amp;&amp;&gt;::value &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> i = <span class="number">10</span>;</span><br><span class="line"><span class="built_in">test_func</span>(i);        <span class="comment">// int&amp; &amp;&amp; is lvalue: 1, reference folding occurs</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>折叠规则：</p>
<p><strong>右值引用</strong>的<strong>右值引用</strong>折叠为<strong>右值引用</strong><code>X&amp;&amp; &amp;&amp; -&gt; X&amp;&amp;</code></p>
<p><strong>其他的引用的引用</strong>都折叠为<strong>左值引用</strong><code>X&amp; &amp;&amp; -&gt; X&amp;, X&amp;&amp; &amp; -&gt; X&amp;, X&amp; &amp; -&gt; X&amp;</code></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// code to validate reference folding </span></span><br><span class="line"></span><br><span class="line"><span class="comment">/// integral_constant</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> _Tp, _Tp __v&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">integral_constant</span> &#123;</span><br><span class="line">    <span class="type">static</span> <span class="keyword">constexpr</span> _Tp     value = __v;</span><br><span class="line">    <span class="keyword">typedef</span> _Tp              value_type;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// The type used as a compile-time boolean with true value.</span></span><br><span class="line"><span class="keyword">using</span> true_type =  integral_constant&lt;<span class="type">bool</span>, <span class="literal">true</span>&gt;;</span><br><span class="line"><span class="comment">/// The type used as a compile-time boolean with false value.</span></span><br><span class="line"><span class="keyword">using</span> false_type = integral_constant&lt;<span class="type">bool</span>, <span class="literal">false</span>&gt;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// is_lvalue_reference</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span>&gt;</span><br><span class="line">  <span class="keyword">struct</span> <span class="title class_">is_lvalue_reference</span></span><br><span class="line">  : <span class="keyword">public</span> false_type &#123; &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> _Tp&gt;</span><br><span class="line">  <span class="keyword">struct</span> <span class="title class_">is_lvalue_reference</span>&lt;_Tp&amp;&gt;</span><br><span class="line">  : <span class="keyword">public</span> true_type &#123; &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">int</span>&amp; int_l_ref;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">int</span>&amp;&amp; int_r_ref;</span><br><span class="line"><span class="keyword">typedef</span> int_l_ref&amp;&amp; int_l_r_ref;</span><br><span class="line"><span class="keyword">typedef</span> int_r_ref&amp;&amp; int_r_r_ref;</span><br><span class="line"><span class="keyword">using</span> int_l_l_ref = int_l_ref&amp;;</span><br><span class="line"><span class="keyword">using</span> int_r_l_ref = int_r_ref&amp;;</span><br><span class="line"></span><br><span class="line">is_lvalue_reference&lt;int_l_ref&gt;::value;          <span class="comment">// 1: lvalue</span></span><br><span class="line">is_lvalue_reference&lt;int_r_ref&gt;::value;          <span class="comment">// 0: rvalue</span></span><br><span class="line">is_lvalue_reference&lt;int_l_r_ref&gt;::value;        <span class="comment">// 1</span></span><br><span class="line">is_lvalue_reference&lt;int_r_r_ref&gt;::value;        <span class="comment">// 0</span></span><br><span class="line">is_lvalue_reference&lt;int_l_l_ref&gt;::value;        <span class="comment">// 1</span></span><br><span class="line">is_lvalue_reference&lt;int_r_l_ref&gt;::value;        <span class="comment">// 1</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>这两个例外导致了两个重要结果：</p>
<ul>
<li>1，如果一个函数的参数是指向模版类型参数的右值引用<code>T&amp;&amp;</code>，则他可以绑定到一个左值，而且</li>
<li>2，如果实参是一个左值，则推断出的模版参数类型为一个左值引用<code>T&amp;</code>，且模板参数被实例化为左值引用<code>T&amp;</code></li>
</ul>
</li>
<li><p>结论：<strong>如果一个函数参数是指向模板参数类型的右值引用<code>T&amp;&amp;</code>，则可以传递给他任意类型的实参</strong></p>
<ul>
<li>如果传递的是右值，则实参的自动推导和普通左值引用的类似</li>
<li>如果传递的是左值引用，则引用折叠为左值引用</li>
<li>如果传递的是右值引用，则引用折叠为右值引用</li>
</ul>
</li>
<li><p>右值引用作为模板参数通常用于两个地方：</p>
<ul>
<li><strong>模板转发其实参</strong></li>
<li><strong>模板被重载</strong></li>
</ul>
</li>
<li><p><code>std::move</code>：模板参数为右值引用的实例，通过引用折叠，可以与任何类型的实参匹配</p>
<p>可以显式的用<code>static_cast</code>将一个<strong>左值</strong>转换为<strong>右值引用</strong>，这样的特性可以允许截断左值（clobber the lvalue）</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// std::move STL source code: gcc/libstdc++-v3/include/bits/move.h</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *  @brief  Convert a value to an rvalue.</span></span><br><span class="line"><span class="comment"> *  @param  __t  A thing of arbitrary type.</span></span><br><span class="line"><span class="comment"> *  @return The parameter cast to an rvalue-reference to allow moving it.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> _Tp&gt;</span><br><span class="line">  _GLIBCXX_NODISCARD</span><br><span class="line">  <span class="keyword">constexpr</span> <span class="keyword">typename</span> std::remove_reference&lt;_Tp&gt;::<span class="function">type&amp;&amp;</span></span><br><span class="line"><span class="function">  <span class="title">move</span><span class="params">(_Tp&amp;&amp; <span class="type">__t</span>)</span> <span class="keyword">noexcept</span></span></span><br><span class="line"><span class="function">  </span>&#123; <span class="keyword">return</span> <span class="keyword">static_cast</span>&lt;<span class="keyword">typename</span> std::remove_reference&lt;_Tp&gt;::type&amp;&amp;&gt;(<span class="type">__t</span>); &#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>regardless pf argument is lvalue reference or rvalue reference, std::move return rvalue reference</p>
</blockquote>
</li>
</ul>
</li>
<li><p><strong>转发</strong>(<em>forward</em>)</p>
<p> 将模板的一个或者多个<strong>实参连同类型不变地转发</strong>给模板内的其他函数</p>
<ul>
<li><p>问题的出现：模板参数<strong>传值</strong>调用，但是内层函数<strong>传引用</strong></p>
  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> F, <span class="keyword">typename</span> T1, <span class="keyword">typename</span> T2&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">flip1</span><span class="params">(F f, T1 t1, T2 t2)</span></span>&#123;</span><br><span class="line">    <span class="built_in">f</span>(t1, t2);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f1</span><span class="params">(<span class="type">int</span> v1, <span class="type">int</span> v2)</span></span>&#123;std::cout &lt;&lt; v1 &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; ++v2 &lt;&lt; std::endl;&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f2</span><span class="params">(<span class="type">int</span> v1, <span class="type">int</span>&amp; v2)</span></span>&#123;std::cout &lt;&lt; v1 &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; ++v2 &lt;&lt; std::endl;&#125;</span><br><span class="line">          </span><br><span class="line"><span class="type">int</span> val2 = <span class="number">1</span>;</span><br><span class="line"><span class="built_in">flip1</span>(f1, <span class="number">1</span>, val2);  <span class="comment">// valid</span></span><br><span class="line"><span class="built_in">flip1</span>(f2, <span class="number">1</span>, val2);  <span class="comment">// not as expected, value of val2 did not change because flip pass val2 as value</span></span><br><span class="line">                     <span class="comment">// the template is instantated as  void flip1(void(*)(int,int), int, int);</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>解决方案1: 使用右值引用作为模板参数</p>
<blockquote>
<p>如果一个函数参数是指向模板类型参数的右值引用(<code>T&amp;&amp;</code>)，则他对应的实参的<strong>const属性</strong>以及<strong>左值&#x2F;右值属性</strong>可以得到保留</p>
<ul>
<li>使用引用可以保留<code>const</code>属性：因为引用的<code>const</code>是底层的，类型推导的时候会携带<code>const</code>属性</li>
<li>使用<strong>右值引用可以保存左值右值属性</strong>：因为引用折叠</li>
</ul>
</blockquote>
  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> F, <span class="keyword">typename</span> T1, <span class="keyword">typename</span> T2&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">flip2</span><span class="params">(F f, T1&amp;&amp; t1, T2&amp;&amp; t2)</span></span>&#123;</span><br><span class="line">    <span class="built_in">f</span>(t1, t2);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> val2 = <span class="number">1</span>;</span><br><span class="line"><span class="type">int</span>&amp;&amp; val2_rf = std::<span class="built_in">move</span>(val2);</span><br><span class="line"><span class="built_in">flip2</span>(f2, <span class="number">1</span>, val2);    <span class="comment">// as expected, because T2 is deduced as int&amp;(int&amp; &amp;&amp; -&gt; int&amp;)</span></span><br></pre></td></tr></table></figure>

<p>  这个版本的<code>flip2</code>函数解决了一半问题，对于接受左值引用的函数工作得很好，但是不能用于接受右值引用作为参数的函数</p>
</li>
<li><p>假如f的某个参数为<strong>右值引用</strong>：</p>
  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">f3</span><span class="params">(<span class="type">int</span> v1, <span class="type">int</span>&amp;&amp; v2)</span></span>&#123;std::cout &lt;&lt; v1 &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; ++v2 &lt;&lt; std::endl;&#125;</span><br><span class="line"><span class="built_in">flip2</span>(f3, <span class="number">1</span>, <span class="number">1</span>);    </span><br></pre></td></tr></table></figure>

<p>  编译不通过：因为<strong>函数的参数都是左值</strong>，此时<strong>f3只是一个普通函数</strong>，所以<strong>不能通过引用折叠将一个左值引用绑定给右值引用</strong>，将<code>flip2</code>的<code>t2</code>参数（左值）传给<code>f3</code>的<code>val2</code>参数（右值）不合法</p>
  <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">d8.cpp:11:10: error: rvalue reference to type &#x27;int&#x27; cannot bind to lvalue of type &#x27;int&#x27;</span><br><span class="line">        f(t1, t2);</span><br><span class="line">              ^~</span><br><span class="line">d8.cpp:41:5: note: in instantiation of function template specialization &#x27;flip2&lt;void (*)(int, int &amp;&amp;), int, int &amp;&gt;&#x27; requested here</span><br><span class="line">    flip2(f3, 1, val2);             // as expected, because T2 is deduced as int&amp;(int&amp; &amp;&amp; -&gt; int&amp;)</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>终极解决方案</strong> <em><strong>std::forward</strong></em></p>
<p>  <code>std::forward</code>可以保持参数的原始类型</p>
<ul>
<li><code>forward</code>必须通过<strong>显式实参调用</strong></li>
<li><code>forward</code>返回<strong>该显式参数类型</strong>的<strong>右值引用</strong>，即<code>forward&lt;T&gt;</code>返回的都是<code>T&amp;&amp;</code><ul>
<li>当<code>t2</code>是右值的时候，<code>T2</code>推导为<code>int</code>，此时<code>forward</code>的返回值为<code>int&amp;&amp;</code></li>
<li>当<code>t2</code>是左值的时候，<code>T2</code>推导为<code>int&amp;</code>，此时<code>forward</code>的返回值为<code>int&amp; &amp;&amp;</code>，折叠为<code>int&amp;</code></li>
</ul>
</li>
<li>当用于一个指向模板参数类型的右值引用<code>T&amp;&amp;</code>时，<code>forward</code>会保持实参类型的所有细节</li>
</ul>
  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> F, <span class="keyword">typename</span> T1, <span class="keyword">typename</span> T2&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">flip3</span><span class="params">(F f, T1&amp;&amp; t1, T2&amp;&amp; t2)</span></span>&#123;</span><br><span class="line">      <span class="built_in">f</span>(std::forward&lt;T1&gt;(t1), std::forward&lt;T2&gt;(t2));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f3</span><span class="params">(<span class="type">int</span> v1, <span class="type">int</span>&amp;&amp; v2)</span></span>&#123;std::cout &lt;&lt; v1 &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; ++v2 &lt;&lt; std::endl;&#125;</span><br><span class="line"><span class="built_in">flip3</span>(f3, <span class="number">1</span>, <span class="number">1</span>);            <span class="comment">// valid, compile pass</span></span><br></pre></td></tr></table></figure>

  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// std::forward STL source code: gcc/libstdc++-v3/include/bits/move.h</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *  @brief  Forward an lvalue.</span></span><br><span class="line"><span class="comment"> *  @return The parameter cast to the specified type.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *  This function is used to implement &quot;perfect forwarding&quot;.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> _Tp&gt;</span></span><br><span class="line"><span class="function">    _GLIBCXX_NODISCARD</span></span><br><span class="line"><span class="function">  <span class="keyword">constexpr</span> _Tp&amp;&amp;</span></span><br><span class="line"><span class="function">  <span class="title">forward</span><span class="params">(<span class="keyword">typename</span> std::remove_reference&lt;_Tp&gt;::type&amp; <span class="type">__t</span>)</span> <span class="keyword">noexcept</span></span></span><br><span class="line"><span class="function">  </span>&#123; <span class="keyword">return</span> <span class="built_in">static_cast</span>&lt;_Tp&amp;&amp;&gt;(<span class="type">__t</span>); &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *  @brief  Forward an rvalue.</span></span><br><span class="line"><span class="comment"> *  @return The parameter cast to the specified type.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *  This function is used to implement &quot;perfect forwarding&quot;.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> _Tp&gt;</span></span><br><span class="line"><span class="function">  _GLIBCXX_NODISCARD</span></span><br><span class="line"><span class="function">  <span class="keyword">constexpr</span> _Tp&amp;&amp;</span></span><br><span class="line"><span class="function">  <span class="title">forward</span><span class="params">(<span class="keyword">typename</span> std::remove_reference&lt;_Tp&gt;::type&amp;&amp; <span class="type">__t</span>)</span> <span class="keyword">noexcept</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    <span class="built_in">static_assert</span>(!std::is_lvalue_reference&lt;_Tp&gt;::value,</span><br><span class="line">    <span class="string">&quot;std::forward must not be used to convert an rvalue to an lvalue&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">static_cast</span>&lt;_Tp&amp;&amp;&gt;(<span class="type">__t</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>因为<code>std::forward</code>的返回值是<code>_Tp&amp;&amp;</code></p>
<ul>
<li>当_Tp是<code>int&amp;</code>的时候，<code>std::forward</code>的返回值为<code>int&amp;</code></li>
<li>当_Tp是<code>int&amp;&amp;</code>的时候，<code>std::forward</code>的返回值为<code>int&amp;&amp;</code></li>
</ul>
</blockquote>
</li>
</ul>
</li>
</ul>
<h3 id="Overloading-and-Template"><a href="#Overloading-and-Template" class="headerlink" title="Overloading and Template"></a>Overloading and Template</h3><ul>
<li>模板函数的重载和匹配<ul>
<li><p>对于一个函数调用，其函数匹配包含<strong>所有模版的实参类型自动推断成功的函数模版</strong></p>
</li>
<li><p>和往常一样，可匹配的函数按照类型转换的优先级先后排序</p>
<ul>
<li>非模板函数按照正常的类型转换去匹配，参见chapter6</li>
<li>模板函数的自动推导中使用的类型转换类型有限，参见chapter16</li>
</ul>
</li>
<li><p>和往常一样，如果<strong>只有一个函数</strong>可以提供<strong>比其他函数更好的匹配</strong>，则选择这个函数，否则：</p>
<ul>
<li><strong>优先选择非模版函数</strong>：如果同样好的函数里面只有一个非模板函数，则选择这个非模板函数(<strong>round 4</strong>)</li>
<li><strong>优先选择更为特例化的模版函数</strong>：如果同样好的函数里面没有非模板函数，而有多个函数模板，且其中的一个模板比其他模板更特例化，则选择这个模板(<strong>round3 and round5</strong>)，比如不可变参模板比可变参数模板更特例化；</li>
<li><strong>否则此调用有歧义</strong>(<em>ambiguous</em>)</li>
</ul>
</li>
<li><p>通常如果忘记了声明函数而用了它，编译器会报错；但是对于重载函数模版而言则不是这样：</p>
<p>  <strong>如果编译器可以从模板实例化出与调用匹配的版本，则缺少我们希望使用的函数的申明也不会报错；事实上，编译器用了一个并不是我们希望使用的函数，这和预期不一致</strong>，会导致不易发现的错误</p>
</li>
</ul>
 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// template function 1, can match lvalue or rvalue</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; </span><br><span class="line"><span class="function">std::string <span class="title">debug_rep</span><span class="params">(<span class="type">const</span> T&amp;)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// template function 2, can only match pointer</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function">std::string <span class="title">debug_rep</span><span class="params">(T*)</span></span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
 <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// round 1</span></span><br><span class="line"><span class="function">std::string <span class="title">s</span><span class="params">(<span class="string">&quot;hi&quot;</span>)</span></span>;    </span><br><span class="line"><span class="built_in">debug_rep</span>(s);    <span class="comment">// only template 1 is matched, because s is not a pointer</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// round 2</span></span><br><span class="line"><span class="built_in">debug_rep</span>(&amp;s);   <span class="comment">// candidates are: template 1. debug_rep(const std::string* &amp;): </span></span><br><span class="line">                 <span class="comment">//                             need to convert std::string* to const std::string&amp;</span></span><br><span class="line">                 <span class="comment">//                 template 2. debug_rep(std::string *): precise match</span></span><br><span class="line">                 <span class="comment">// so template 2 is precisely matched</span></span><br><span class="line"><span class="comment">// round 3</span></span><br><span class="line">std::string&amp; sp = &amp;s;</span><br><span class="line"><span class="built_in">debug_rep</span>(sp);   <span class="comment">// candidated are: template 1, debug_rep(const std::string* &amp;); </span></span><br><span class="line">                 <span class="comment">//                 template 2, debug_rep(std::string *);</span></span><br><span class="line">                 <span class="comment">// because template 2 is more specicalized than template 1, than template 2 is matched</span></span><br></pre></td></tr></table></figure>
 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// normal non-template function</span></span><br><span class="line"><span class="function">std::string <span class="title">debug_rep</span><span class="params">(<span class="type">const</span> std::string&amp;)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// round 4, consider non-template fucntion </span></span><br><span class="line"><span class="built_in">debug_rep</span>(s);    <span class="comment">// candidate are 1. template 1, debug_rep(const std::string &amp;);</span></span><br><span class="line">                 <span class="comment">//               2. non-template function, debug_rep(comst std::string&amp;);</span></span><br><span class="line">                 <span class="comment">// though the two candicates all matches precisely, non-template function</span></span><br><span class="line">                 <span class="comment">// is prefered，so non-template function is matched</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// round 5</span></span><br><span class="line"><span class="built_in">debug_rep</span>(<span class="string">&quot;hello world&quot;</span>); </span><br><span class="line"><span class="comment">// candicated are: 1, debug_rep(const char[10] &amp;), T is char[10], </span></span><br><span class="line"><span class="comment">//                              string literal is char array </span></span><br><span class="line"><span class="comment">//                 2, debug_rep(const char*), T is const char</span></span><br><span class="line"><span class="comment">//                 3, debug_rep(const std::string&amp;), convert char* to std::string</span></span><br><span class="line"><span class="comment">// because candidate 3 has the need to do type convert(char* to string), so it is </span></span><br><span class="line"><span class="comment">// not better matched than candidates 1 and 2, also candicate 2 is more specialized</span></span><br><span class="line"><span class="comment">// than candidate 1, so candidate 2 is matched                </span></span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="Variadic-Template"><a href="#Variadic-Template" class="headerlink" title="Variadic Template"></a>Variadic Template</h3><ul>
<li><p>参数包(<em>pack</em>)</p>
<p>可变数目的参数被称为参数包，可以使用省略号<code>...</code>代表参数包；存在两种参数包：</p>
<ul>
<li>模板参数包：在模板参数列表里面，<code>class...</code> or <code>template...</code>表示0个或多个类型</li>
<li>函数参数包：一个类型名后面更一个<code>...</code>表示0个或者多个此给定类型的参数</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> ... Args&gt;;     <span class="comment">// Args 是一个模板参数包，表示模板可以接受0个或者多个类型</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">foo</span><span class="params">(<span class="type">const</span> T&amp;, <span class="type">const</span> Args&amp;... residual)</span></span>;  <span class="comment">// residual是一个函数参数包，表示0个或者多个参数</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>可以使用<code>sizeof...</code>运算符得到可变类型和可变参数的数量</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> ... Args&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">foo</span><span class="params">(Args... args)</span></span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="keyword">sizeof</span>...(Args) &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="keyword">sizeof</span>...(args) &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">foo</span>(<span class="string">&quot;1&quot;</span>, <span class="number">1</span>, <span class="number">1.0</span>);        <span class="comment">// print 3, 3</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>可变参数的函数通常是递归的</p>
<p>为了终止递归，需要定义一个非可变参数的函数模板；<strong>因为非可变参数函数比起可变参数函数是更加特例化的，所以当两种函数都可以精确匹配的时候，优先考虑非可变参数函数</strong>；</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 用于终止递归, 并打印最后一个元素</span></span><br><span class="line"><span class="comment">// 必须在可变参数版本之前声明, 若在之后声明, 则无法通过编译, </span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function">std::ostream&amp; <span class="title">print</span><span class="params">(std::ostream&amp; os, <span class="type">const</span> T&amp;t)</span></span>&#123;<span class="keyword">return</span> os &lt;&lt; t;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 可变参数函数通常是递归的,每一步处理最前面的一个实参, 然后用剩余参数调用自身.</span></span><br><span class="line"><span class="comment">// 除了最后一个元素之外的其他元素都会调用这个版本的print</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span>... Args&gt;    </span><br><span class="line"><span class="function">std::ostream&amp; <span class="title">print</span><span class="params">(std::ostream&amp; os, <span class="type">const</span> T&amp; t, <span class="type">const</span> Args&amp;... residual)</span></span>&#123; <span class="comment">//  Args&amp;...包扩展，见下节解释</span></span><br><span class="line">    os &lt;&lt; t &lt;&lt; <span class="string">&quot; , &quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">print</span>(os, residual...);        <span class="comment">// residual...包扩展</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>针对以上代码：</p>
<p>非可变参版本的声明必须在可变参函数之前，否则可变参版本的<code>print</code>将会一直调用自身直到耗尽参数包，仅用一个os参数去调用<code>print</code>，会无法通过编译</p>
<blockquote>
<p>note:   candidate expects at least 2 arguments, 1 provided</p>
</blockquote>
<p>最后一次调用，参数就只有<code>os</code>和一个待打印值，所以以上两个模板都可以匹配；但是因为不可变参数模板更特例化，所以匹配非可变参数模板</p>
</li>
<li><p>参数包扩展(<em>pack expansion</em>)</p>
<p>对于一个<code>参数包</code>(上面的<code>redidual</code>参数)，我们除了获取其大小(<code>sizeof...</code>)外，唯一能做的就是扩展它(<code>expand</code>)；当扩展一个参数包的时候，我们还需要提供用于每个扩展元素的模式， 这里的<code>模式</code>通常为一些<strong>类型限定修饰符</strong>；</p>
<p>扩展包就是<strong>对包中的每一个元素都应用一个指定的模式</strong>，<strong>并得到展开后的逗号分隔的列表</strong>；通过在<strong>模式</strong>右边放一个省略号(<code>...</code>)<strong>触发扩展操作</strong></p>
<blockquote>
<p><strong>扩展模版参数包：</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">std::ostream&amp; <span class="title">print</span><span class="params">(std::ostream&amp; os, <span class="type">const</span> T&amp; t, <span class="type">const</span> Args&amp;... residual)</span></span>&#123; <span class="comment">//Args&amp;...包扩展，见下节解释</span></span><br></pre></td></tr></table></figure>

<p><code>const Args&amp;... residual</code>扩展模板参数包,将<code>const type&amp;</code>应用到包中的每一个元素,为<code>print</code>生成参数列表。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(cout, <span class="number">2</span>, <span class="number">3.14</span>, <span class="string">&quot;asd&quot;</span>); <span class="comment">// 包中有两个参数</span></span><br></pre></td></tr></table></figure>

<p>此调用被实例化为</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ostream&amp; <span class="title">print</span><span class="params">(ostream&amp;, <span class="type">const</span> <span class="type">int</span>&amp;, <span class="type">const</span> <span class="type">double</span>&amp;, <span class="type">const</span> <span class="type">char</span>[<span class="number">4</span>]&amp;)</span></span>;</span><br></pre></td></tr></table></figure>



<p><strong>扩展函数参数包：</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">return</span> <span class="built_in">print</span>(os, residual...);        <span class="comment">// residual...包扩展</span></span><br></pre></td></tr></table></figure>

<p>在<code>print</code>函数的<code>return</code>语句中的递归调用也触发了扩展(有<code>...</code>出现)，只是它<strong>直接将<code>residual</code>扩展为逗号分隔的参数列表</strong>, 而<strong>没有改变各个元素本身的类型</strong>。</p>
<p>考虑更清晰的一个例子,有这样一个函数:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function">string <span class="title">debug_rep</span><span class="params">(<span class="type">const</span> T&amp; t)</span></span>&#123;</span><br><span class="line">    ostringstream ss;</span><br><span class="line">    ss &lt;&lt; t;</span><br><span class="line">    <span class="keyword">return</span> ss.<span class="built_in">str</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>它通过流操作符从传进来的参数获取一个字符串.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span>... Args&gt;</span><br><span class="line"><span class="function">ostream &amp;<span class="title">errorMsg</span><span class="params">(ostream&amp;os, <span class="type">const</span> Args&amp;... rest)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">print</span>(os, <span class="built_in">debug_rep</span>(rest)...);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>errorMsg</code>将传进来的参数包<code>rest</code>用<code>debug_rep</code>扩展</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">errorMsg</span>(cerr, fcnName, code.<span class="built_in">num</span>(), otherData, <span class="string">&quot;balabala&quot;</span>, item);</span><br></pre></td></tr></table></figure>

<p>扩展结果:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(cerr, <span class="built_in">debug_rep</span>(fcnName), <span class="built_in">debug_rep</span>(code.<span class="built_in">num</span>(),</span><br><span class="line">      <span class="built_in">debug_rep</span>(otherData), <span class="built_in">debug_rep</span>(<span class="string">&quot;balabala&quot;</span>),</span><br><span class="line">      <span class="built_in">debug_rep</span>(item)));</span><br></pre></td></tr></table></figure>

<p>相对的:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(os, <span class="built_in">debug_rep</span>(rest...));</span><br></pre></td></tr></table></figure>

<p>展开为将包传递给了<code>debug_rep</code>:<code>print(os, debug_rep(a1,a2,a3...an))</code>，所以这个调用会失败,<code>debug_rep</code>没有匹配的参数列表。</p>
</blockquote>
</li>
<li><p>转发参数包：新标准下可以<strong>组合使用</strong><code>std::forward</code>和<code>参数包扩展</code>，比如<code>std::vector::emplace_back</code>就是可变参数</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Args...&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">StrVec::emplace_back</span><span class="params">(Args&amp;&amp;... args)</span></span>&#123;</span><br><span class="line">    <span class="built_in">check_n_alloc</span>();</span><br><span class="line">    alloc.<span class="built_in">construct</span>(first_free++, std::forward&lt;Args&gt;(args)...);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>std::forward&lt;Args&gt;(args)...</code><strong>既扩展了模板参数包</strong><code>Args</code><strong>又拓展了函数参数包</strong><code>args</code>，生成了<code>std::forward&lt;T_i&gt;(args_i)</code>形式的元素；</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// std::vector emplace STL实现：gcc/libstdc++-v3/include/bits/vector.tcc</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> _Tp, <span class="keyword">typename</span> _Alloc&gt;</span><br><span class="line">  <span class="keyword">template</span>&lt;<span class="keyword">typename</span>... _Args&gt;</span><br><span class="line">    _GLIBCXX20_CONSTEXPR</span><br><span class="line">    <span class="keyword">auto</span></span><br><span class="line">    vector&lt;_Tp, _Alloc&gt;::</span><br><span class="line">    _M_emplace_aux(const_iterator __position, _Args&amp;&amp;... __args)</span><br><span class="line">    -&gt; iterator</span><br><span class="line">    &#123;   </span><br><span class="line">      <span class="type">const</span> <span class="keyword">auto</span> __n = __position - <span class="built_in">cbegin</span>();</span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">this</span>-&gt;_M_impl._M_finish != <span class="keyword">this</span>-&gt;_M_impl._M_end_of_storage)</span><br><span class="line">        <span class="keyword">if</span> (__position == <span class="built_in">cend</span>())</span><br><span class="line">          &#123;   </span><br><span class="line">            _GLIBCXX_ASAN_ANNOTATE_GROW(<span class="number">1</span>);</span><br><span class="line">            _Alloc_traits::<span class="built_in">construct</span>(<span class="keyword">this</span>-&gt;_M_impl, <span class="keyword">this</span>-&gt;_M_impl._M_finish,</span><br><span class="line">                         std::forward&lt;_Args&gt;(__args)...);</span><br><span class="line">            ++<span class="keyword">this</span>-&gt;_M_impl._M_finish;</span><br><span class="line">            _GLIBCXX_ASAN_ANNOTATE_GREW(<span class="number">1</span>);</span><br><span class="line">          &#125;   </span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">          &#123;   </span><br><span class="line">            <span class="comment">// We need to construct a temporary because something in __args...</span></span><br><span class="line">            <span class="comment">// could alias one of the elements of the container and so we</span></span><br><span class="line">            <span class="comment">// need to use it before _M_insert_aux moves elements around.</span></span><br><span class="line">            _Temporary_value __tmp(<span class="keyword">this</span>, std::forward&lt;_Args&gt;(__args)...);</span><br><span class="line">            _M_insert_aux(<span class="built_in">begin</span>() + __n, std::<span class="built_in">move</span>(__tmp._M_val()));</span><br><span class="line">          &#125;   </span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">        _M_realloc_insert(<span class="built_in">begin</span>() + __n, std::forward&lt;_Args&gt;(__args)...);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">iterator</span>(<span class="keyword">this</span>-&gt;_M_impl._M_start + __n);</span><br><span class="line">    &#125;   </span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="Template-Specialization"><a href="#Template-Specialization" class="headerlink" title="Template Specialization"></a>Template Specialization</h3><ul>
<li><p>全(局)特化(<em>full specialization</em>)</p>
<p>将模板<strong>所有的类型都进行特化</strong>，应使用关键字<code>template</code>后跟一对空尖括号<code>&lt;&gt;</code>；空尖括号指明我们将为原模版的所有模版参数都提供实参；</p>
<p><strong>在使用任何模版实例化的代码之前，特例化版本的代码的声明也必须在作用域中</strong>，否则在实例化的时候编译器将无法使用特例化版本；<strong>模版及其特例化版本应该声明在同一个头文件中</strong>；所有同名模版的声明应该放在前面，然后是这些模版的特例化版本；</p>
<p>当定义函数模版的特例化版本的时候，<strong>本质是接管了编译器的工作实例化了一个函数模版</strong>，而<strong>非重载</strong>它；因此<strong>函数模版的特例化是不影响函数的匹配的；</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="function"><span class="type">int</span> <span class="title">compare</span><span class="params">(<span class="type">const</span> T&amp;, <span class="type">const</span> T&amp;)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;&gt;   <span class="comment">// 函数模版全特化</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">compare</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* <span class="type">const</span> &amp;, <span class="type">const</span> <span class="type">char</span>* <span class="type">const</span> &amp;)</span></span>&#123; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T1</span>, <span class="keyword">class</span> <span class="title class_">T2</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Test</span>&#123;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;&gt;  <span class="comment">// 类模版全特化</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Test</span>&lt;<span class="type">int</span> , <span class="type">char</span>&gt;&#123;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>和继承不同，<strong>类模板的“原型”和它的特化类在实现上是<em>没有关系</em>的，</strong>并不是在类模板中写了 <code>ID</code> 这个Member，那所有的特化就必须要加入 <code>ID</code> 这个Member，或者特化就自动有了这个成员。完全没这回事。</p>
<p><strong>类模板和类模板的特化的作用，仅仅是指导编译器选择哪个编译，但是特化之间、特化和它原型的类模板之间，是分别独立实现的</strong>。实际上，<strong>全特化和类模板只是名称有关联</strong>。</p>
<p>我们把类模板改成以下形式，或许能看的更清楚一点：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">  </span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TypeToID</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> <span class="type">const</span> NotID = <span class="number">-2</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;&gt; </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TypeToID</span>&lt;<span class="type">float</span>&gt; &#123;       <span class="comment">// 全特化</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> <span class="type">const</span> ID = <span class="number">1</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">TypeToID&lt;<span class="type">float</span>&gt;::ID;          <span class="comment">// Print &quot;1&quot;</span></span><br><span class="line">TypeToID&lt;<span class="type">float</span>&gt;::NotID;       <span class="comment">// Error! TypeToID&lt;float&gt;使用的特化的类，这个类的实现没有NotID这个成员。</span></span><br><span class="line">TypeToID&lt;<span class="type">double</span>&gt;::ID;         <span class="comment">// Error! TypeToID&lt;double&gt;是由模板类实例化出来的，它只有NotID，没有ID这个成员。</span></span><br></pre></td></tr></table></figure>

<p><strong>特例化的模板类的实参列表必须和相应的基础模板参数列表一一对应</strong>。例如，我们不能用一个非类型值来替换一个模板类型参数。然而，<strong>如果模板参数具有缺省模板实参，那么用来替换的模板实参就是可选的</strong>（即不是必须的）</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Types</span>  &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">typedef</span> <span class="type">int</span> I;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> U = <span class="keyword">typename</span> Types&lt;T&gt;::I&gt;</span><br><span class="line"><span class="keyword">class</span> S;　　　　　　　　　　</span><br><span class="line"> </span><br><span class="line"><span class="keyword">template</span>&lt;&gt; <span class="keyword">class</span> <span class="title class_">S</span>&lt;<span class="type">void</span>&gt;  &#123;　　　　  <span class="comment">// valid　　　</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">template</span>&lt;&gt; <span class="keyword">class</span> <span class="title class_">S</span>&lt;<span class="type">char</span>, <span class="type">char</span>&gt;;     <span class="comment">// valid</span></span><br><span class="line"><span class="keyword">template</span>&lt;&gt; <span class="keyword">class</span> <span class="title class_">S</span>&lt;<span class="type">char</span>, <span class="number">0</span>&gt;;        <span class="comment">// 错误：不能用0来替换typename U</span></span><br></pre></td></tr></table></figure>

<p>对于<strong>特化声明</strong>而言，因为它并<strong>不是模板声明，所以应该使用（位于类外部）的普通成员定义语法，来定义全局类模板特化的成员</strong>（也就是说，不能指定<code>template&lt;&gt;</code>前缀）</p>
  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">S</span>;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">template</span>&lt;&gt; <span class="keyword">class</span> <span class="title class_">S</span>&lt;<span class="type">char</span>**&gt; &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//下面的定义不能使用template&lt;&gt;前缀</span></span><br><span class="line"><span class="type">void</span> S&lt;<span class="type">char</span>**&gt;::<span class="built_in">print</span>() <span class="type">const</span> &#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;pointer to pointer to char\n&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>我们可以只特例化特定成员而不是这个模板；<code>类的成员模板</code>、<code>类模板的成员函数</code>和<code>普通的静态成员变量</code>也可以被全局特化</strong>；</p>
<p>实现特化的语法会要求给每个外围类模板加上template&lt;&gt;前缀。如果要对一个成员模板进行特化，也必须加上另一个template&lt;&gt;前缀，来说明该声明表示的是一个特化</p>
  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Foo</span>&#123;</span><br><span class="line">    <span class="built_in">Foo</span>(<span class="type">const</span> T&amp;t = <span class="built_in">T</span>()): <span class="built_in">mem</span>(t)&#123;<span class="comment">/* do something */</span>&#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Bar</span><span class="params">()</span></span>&#123;<span class="comment">/* do something */</span>&#125;;</span><br><span class="line">    T mem;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;&gt;</span><br><span class="line"><span class="type">void</span> Foo&lt;<span class="type">int</span>&gt;::<span class="built_in">Bar</span>()&#123;<span class="comment">/* do something */</span>&#125;</span><br><span class="line"></span><br><span class="line">Foo&lt;std::string&gt; fs;   <span class="comment">// 实例化Foo&lt;std::string&gt;::Foo()</span></span><br><span class="line">fs.<span class="built_in">Bar</span>();              <span class="comment">// 实例化Foo&lt;std::string&gt;::Bar()</span></span><br><span class="line">Foo&lt;<span class="type">int</span>&gt; fi;           <span class="comment">// 实例化Foo&lt;int&gt;::Foo()</span></span><br><span class="line">fi.<span class="built_in">Bar</span>();              <span class="comment">// 实例化我们特例化的Foo&lt;int&gt;::Bar()</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>偏特化(<em>partial specialization</em>)：</p>
<p>偏特化分为两种，一种是<strong>部分类型特化</strong>，一种是<strong>对模板类型的进一步限制</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T1</span>, <span class="keyword">class</span> <span class="title class_">T2</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Test2</span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//部分特化</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T1</span>&gt;  <span class="comment">//此处只需写未进行特化的模板类型，特化过的就不用写</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Test2</span>&lt;T1 , <span class="type">char</span>&gt;&#123;   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T1</span>, <span class="keyword">class</span> <span class="title class_">T2</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Test2</span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//对模板类型的范围做出一定的限制，限制实参为T*指针</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T1</span> , <span class="keyword">class</span> <span class="title class_">T2</span> &gt;  <span class="comment">//此处只需写未进行特化的模板类型</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Test2</span>&lt;T1* , T2*&gt;&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>考虑我们要写一个向量逐分量乘法。只不过这个向量，它非常的大。所以为了保证速度，我们需要使用SIMD指令进行加速。假设我们有以下指令可以使用：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Int8,<span class="number">16</span>: N/A</span><br><span class="line">Int32  : <span class="built_in">VInt32Mul</span>(int32x4, int32x4)</span><br><span class="line">Int64  : <span class="built_in">VInt64Mul</span>(int64x4, int64x4)</span><br><span class="line">Float  : <span class="built_in">VInt64Mul</span>(floatx2, floatx2)</span><br></pre></td></tr></table></figure>

<p>所以对于<code>Int8</code>和<code>Int16</code>，我们需要提升到<code>Int32</code>，而<code>Int32</code>和<code>Int64</code>，各自使用自己的指令。所以我们需要实现下的逻辑：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(v4a, v4b : vectorsA, vectorsB) &#123;</span><br><span class="line"> <span class="keyword">if</span> type is Int8, <span class="function">Int16</span></span><br><span class="line"><span class="function">     <span class="title">VInt32Mul</span><span class="params">( ConvertToInt32(v4a), ConvertToInt32(v4b) )</span></span></span><br><span class="line"><span class="function"> elif type is Int32</span></span><br><span class="line"><span class="function">     <span class="title">VInt32Mul</span><span class="params">( v4a, v4b )</span></span></span><br><span class="line"><span class="function"> elif type is Float</span></span><br><span class="line"><span class="function">     ...</span></span><br><span class="line"><span class="function">&#125;</span></span><br></pre></td></tr></table></figure>

<p>如何根据 <code>type</code> 分别提供我们需要的实现？这里有两个难点。</p>
<ul>
<li>首先， <code>if(type == xxx) &#123;&#125;</code> 是不存在于C++中的。</li>
<li>第二，即便存在根据 <code>type</code> 的分配方法，我们也不希望它在<strong>运行时branch</strong>，这样会变得很慢。我们希望它能按照类型直接就把代码编译好，就跟直接写的一样。</li>
</ul>
<p><strong>部分特化&#x2F;偏特化</strong> 和 <strong>特化</strong> 相当于是模板实例化过程中的<code>if-then-else</code>。这使得我们根据不同类型，选择不同实现的需求得以实现；</p>
<p>SFINAE(<a target="_blank" rel="noopener" href="https://sg-first.gitbooks.io/cpp-template-tutorial/content/jie_te_hua_yu_pian_te_hua.html">Substitution failure is not an error</a> )</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">RemovePointer</span> &#123;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">RemovePointer</span>&lt;T*&gt; &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">typedef</span> T Result;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 用RemovePointer后，那个Result就是把float*的指针处理掉以后的结果：float啦。</span></span><br><span class="line">RemovePointer&lt;<span class="type">float</span>*&gt;::Result x = <span class="number">5.0f</span>;        </span><br></pre></td></tr></table></figure>

<p>如何理解偏特化的写法：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 我们这个模板的基本形式是什么？</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="keyword">class</span> <span class="title class_">AddFloatOrMulInt</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 但是这个类，是给T是Int的时候用的，于是我们写作</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">AddFloatOrMulInt</span>&lt;<span class="type">int</span>&gt;</span><br><span class="line"><span class="comment">// 当然，这里编译是通不过的。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 但是它又不是个普通类，而是类模板的一个特化（特例）。</span></span><br><span class="line"><span class="comment">// 所以前面要加模板关键字template，</span></span><br><span class="line"><span class="comment">// 以及模板参数列表</span></span><br><span class="line"><span class="keyword">template</span> &lt;/* 这里要填什么？ */&gt; <span class="keyword">class</span> <span class="title class_">AddFloatOrMulInt</span>&lt;<span class="type">int</span>&gt;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 最后，模板参数列表里面填什么？因为原型的T已经被int取代了。所以这里就不能也不需要放任何额外的参数了。</span></span><br><span class="line"><span class="comment">// 所以这里放空。</span></span><br><span class="line"><span class="keyword">template</span> &lt;&gt; <span class="keyword">class</span> <span class="title class_">AddFloatOrMulInt</span>&lt;<span class="type">int</span>&gt; &#123;</span><br><span class="line">    <span class="comment">// ... 针对Int的实现 ... </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Reference: <a target="_blank" rel="noopener" href="https://sg-first.gitbooks.io/cpp-template-tutorial/content/">https://sg-first.gitbooks.io/cpp-template-tutorial/content/</a></p>
</blockquote>
<p>除了简单的指针、<code>const</code>和<code>volatile</code>修饰符，其他的<strong>类模板也可以作为偏特化时的“模式”</strong>出现，例如示例8，它要求传入同一个类型的<code>unique_ptr</code>和<code>shared_ptr</code></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> U&gt; </span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">X</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 偏特化</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;             </span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">X</span>&lt;unique_ptr&lt;T&gt;, shared_ptr&lt;T&gt;&gt;; </span><br></pre></td></tr></table></figure>
</li>
<li><p>函数模板特例化</p>
<ul>
<li><p>为了指明我们正在特例化一个模板，应使用<code>template</code>关键字后跟上<code>&lt;&gt;</code>空的尖括号；<strong>空的尖括号表示会为所有参数提供实参</strong></p>
</li>
<li><p>当我们特例化一个<strong>函数模板</strong>的时候，<strong>必须为原模板中的每个参数提供实参，不可部分指定</strong>；且参数类型必须与前面声明的模板中对应的类型匹配</p>
</li>
<li><p>当定义了函数模板的特例化版本时，本质上是接管了编译器该做的工作，即我们为模板的某个特殊的实例提供了定义；所有<strong>对函数模板的特例化，本质上是实例化一个模板，而不是对原模板的重载</strong>；所以对函数模板的特例化并不影响模板的匹配</p>
<blockquote>
<p>函数模版的全特化版本不参与函数重载解析，并且优先级低于函数基础模版参与匹配的原因是：*C++*标准委员会认为如果因为程序员随意写了一个函数模版的全特化版本，而使得原先的重载函数模板匹配结果发生改变（也就是改变了约定的重载解析规则）是不能接受的。</p>
</blockquote>
</li>
<li><p>使用模板特化时，必须要先有<strong>基础的模板函数</strong></p>
<blockquote>
<p>未特化的模版通常也叫做底层基础模版。函数模版的全特化到底是哪个函数基础模版的特化，需要参考可见原则，也就是说当特化版本声明时，它只可能特化的是当前编译单元已经定义的函数基础模版。</p>
</blockquote>
</li>
<li><p><strong>类模版可以偏特化和全特化，而函数模版只能进行全特化</strong>，但是由于函数模版可以重载，<strong>我们通过重载可以获得和偏特化几乎相同的效果</strong>。</p>
</li>
<li><p>我们可以直接写<strong>非模板函数</strong>来重载函数模板，这样的非模板函数在函数匹配上比模板的优先级更高；所以很多时候，<strong>要避免函数模板的特例化，直接重载函数</strong>就好了<a target="_blank" rel="noopener" href="http://www.gotw.ca/publications/mill17.htm">reference: Why Not Specialize Function Templates?</a></p>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 基础的模板函数</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">compare</span><span class="params">(<span class="type">const</span> T&amp;, <span class="type">const</span> T&amp;)</span></span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;generic compare&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 特化模板函数</span></span><br><span class="line"><span class="keyword">template</span>&lt;&gt;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">compare</span><span class="params">(<span class="type">const</span> <span class="type">int</span>&amp;, <span class="type">const</span> <span class="type">int</span>&amp;)</span></span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;int compare&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="type">int</span> M, <span class="type">int</span> N&gt;</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">compare</span><span class="params">(<span class="type">const</span> <span class="type">char</span>(&amp;)[M], <span class="type">const</span> <span class="type">char</span> (&amp;)[N])</span></span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;char array compare&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span> &lt;&gt;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">compare</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* <span class="type">const</span> &amp;, <span class="type">const</span> <span class="type">char</span>* <span class="type">const</span> &amp;)</span></span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;const char* const compare&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">char</span>* p1 = <span class="string">&quot;123&quot;</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">char</span>* p2 = <span class="string">&quot;456&quot;</span>;    </span><br><span class="line"><span class="built_in">compare</span>(p1, p2);            <span class="comment">// const char* const compare</span></span><br><span class="line"><span class="built_in">compare</span>(<span class="number">1</span>, <span class="number">2</span>);              <span class="comment">// int compare</span></span><br><span class="line"><span class="built_in">compare</span>(<span class="literal">true</span>, <span class="literal">true</span>);        <span class="comment">// generic compare</span></span><br><span class="line"><span class="built_in">compare</span>(<span class="string">&quot;hi&quot;</span>, <span class="string">&quot;mom&quot;</span>);       <span class="comment">// char array compare</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>如何理解：参数类型必须与前面声明的模板中对应的类型匹配：</p>
<p>如果把对<code>const char*</code>特例化的模板写成：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;&gt;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">compare</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* <span class="type">const</span>, <span class="type">const</span> <span class="type">char</span>* <span class="type">const</span>)</span></span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;const char* const compare&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// or</span></span><br><span class="line"><span class="keyword">template</span> &lt;&gt;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">compare</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* &amp;, <span class="type">const</span> <span class="type">char</span>* &amp;)</span></span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;const char* const compare&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>编译器会报错：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">m.cpp:44:5: error: no function template matches function template specialization &#x27;compare&#x27;</span><br><span class="line">int compare(const char* const, const char* const)&#123;</span><br><span class="line">    ^</span><br><span class="line">m.cpp:34:5: note: candidate template ignored: could not match &#x27;const type-parameter-0-0 &amp;&#x27; against &#x27;const char *&#x27;</span><br><span class="line">int compare(const T&amp;, const T</span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">m.cpp:44:5: error: no function template matches function template specialization &#x27;compare&#x27;</span><br><span class="line">int compare(const char* &amp;, const char* &amp;)&#123;</span><br><span class="line">    ^</span><br><span class="line">m.cpp:34:5: note: candidate template ignored: cannot deduce a type for &#x27;T&#x27; that would make &#x27;const T&#x27; equal &#x27;const char *&#x27;</span><br><span class="line">int compare(const T&amp;, const T&amp;)&#123;</span><br></pre></td></tr></table></figure>

<p>这是因为原来的模板里面参数为<code>const T&amp;</code>，是底层const，而<code>pointer</code>前面的const是顶层const，后面的才是底层const</p>
<p>所以对<code>char*</code>的特例化的模板参数应该写为<code>const char* const &amp;</code>；</p>
<p>如果模板参数写成<code>char* const &amp;</code>可以么？</p>
<p>不可以，如果模板参数是<code>char* const &amp;</code>的，则无法匹配实参类型为<code>const char*</code>的调用，即：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">char</span>* p1 = <span class="string">&quot;123&quot;</span>, * p2 = <span class="string">&quot;456&quot;</span>;    </span><br><span class="line"><span class="built_in">compare</span>(p1, p2);       <span class="comment">// will print generic compare, not const char* const compare</span></span><br></pre></td></tr></table></figure>

<p>如果<strong>手工写非模版函数重载函数模板，函数的匹配又会变化</strong>：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 基础的模板函数</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">compare</span><span class="params">(<span class="type">const</span> T&amp;, <span class="type">const</span> T&amp;)</span></span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;generic compare&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 特化模板函数</span></span><br><span class="line"><span class="keyword">template</span> &lt;&gt;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">compare</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* <span class="type">const</span> &amp;, <span class="type">const</span> <span class="type">char</span>* <span class="type">const</span> &amp;)</span></span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;const char* const compare&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 非模版函数，重载函数模板</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">compare</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* <span class="type">const</span> &amp;, <span class="type">const</span> <span class="type">char</span>* <span class="type">const</span> &amp;)</span></span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;non-template const char* const compare&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">char</span>* p1 = <span class="string">&quot;123&quot;</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">char</span>* p2 = <span class="string">&quot;456&quot;</span>;</span><br><span class="line"><span class="built_in">compare</span>(p1, p2);                 <span class="comment">// non-template const char* const compare</span></span><br><span class="line"><span class="built_in">compare</span>(<span class="string">&quot;hi&quot;</span>, <span class="string">&quot;mom&quot;</span>);            <span class="comment">// non-template const char* const compare</span></span><br></pre></td></tr></table></figure>

<p>这是因为<strong>非模板函数的匹配优先级比模板函数更高(chapter16)，而且模板的特例化并不影响模板的匹配</strong></p>
</blockquote>
</li>
</ul>

    </div>

    
    
    
      


    <footer class="post-footer">
          

<div class="post-copyright">
<ul>
  <li class="post-copyright-author">
      <strong>本文作者： </strong>PangWong
  </li>
  <li class="post-copyright-link">
      <strong>本文链接：</strong>
      <a href="https://pangwong.github.io/blog/2022/06/cpp-primer-chapter16/" title="Reading Note of CppPrimer-Chapter16">https://pangwong.github.io/blog/2022/06/cpp-primer-chapter16/</a>
  </li>
  <li class="post-copyright-license">
    <strong>版权声明： </strong>本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" rel="noopener" target="_blank"><i class="fab fa-fw fa-creative-commons"></i>BY-NC-SA</a> 许可协议。转载请注明出处！
  </li>
</ul>
</div>

          <div class="post-tags">
              <a href="/tags/reading-notes/" rel="tag"><i class="fa fa-tag"></i> reading notes</a>
              <a href="/tags/cpp-primer/" rel="tag"><i class="fa fa-tag"></i> cpp-primer</a>
              <a href="/tags/template/" rel="tag"><i class="fa fa-tag"></i> template</a>
              <a href="/tags/function-template/" rel="tag"><i class="fa fa-tag"></i> function template</a>
              <a href="/tags/class-template/" rel="tag"><i class="fa fa-tag"></i> class template</a>
              <a href="/tags/typename/" rel="tag"><i class="fa fa-tag"></i> typename</a>
              <a href="/tags/member-template/" rel="tag"><i class="fa fa-tag"></i> member template</a>
              <a href="/tags/explicit-instantiation/" rel="tag"><i class="fa fa-tag"></i> explicit instantiation</a>
              <a href="/tags/reference-collapsing/" rel="tag"><i class="fa fa-tag"></i> reference collapsing</a>
              <a href="/tags/std-move/" rel="tag"><i class="fa fa-tag"></i> std::move</a>
              <a href="/tags/std-forward/" rel="tag"><i class="fa fa-tag"></i> std::forward</a>
              <a href="/tags/variadic-template/" rel="tag"><i class="fa fa-tag"></i> variadic template</a>
              <a href="/tags/pack-expansion/" rel="tag"><i class="fa fa-tag"></i> pack expansion</a>
              <a href="/tags/template-full-specialization/" rel="tag"><i class="fa fa-tag"></i> template full specialization</a>
              <a href="/tags/template-partial-specialization/" rel="tag"><i class="fa fa-tag"></i> template partial specialization</a>
          </div>

        

          <div class="post-nav">
            <div class="post-nav-item">
            </div>
            <div class="post-nav-item">
                <a href="/blog/2022/06/cpp-primer-chapter15/" rel="next" title="Reading Note of CppPrimer-Chapter15">
                  Reading Note of CppPrimer-Chapter15 <i class="fa fa-chevron-right"></i>
                </a>
            </div>
          </div>
    </footer>
  </article>
</div>






    <div class="comments gitalk-container"></div>
</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">


<div class="copyright">
  &copy; 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">PangWong</span>
</div>
<div class="wordcount">
  <span class="post-meta-item">
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-line"></i>
    </span>
      <span>站点总字数：</span>
    <span title="站点总字数">270k</span>
  </span>
  <span class="post-meta-item">
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
      <span>站点阅读时长 &asymp;</span>
    <span title="站点阅读时长">4:06</span>
  </span>
</div>
<div class="busuanzi-count">
    <span class="post-meta-item" id="busuanzi_container_site_uv">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-item" id="busuanzi_container_site_pv">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>

    </div>
  </footer>

  
  <script src="https://cdn.jsdelivr.net/npm/animejs@3.2.1/lib/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/medium-zoom@1.0.6/dist/medium-zoom.min.js" integrity="sha256-EdPgYcPk/IIrw7FYeuJQexva49pVRZNmt3LculEr7zM=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/lozad@1.16.0/dist/lozad.min.js" integrity="sha256-mOFREFhqmHeQbXpK2lp4nA3qooVgACfh88fpJftLBbc=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/pangu@4.0.7/dist/browser/pangu.min.js" integrity="sha256-j+yj56cdEY2CwkVtGyz18fNybFGpMGJ8JxG3GSyO2+I=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/schemes/muse.js"></script><script src="/js/next-boot.js"></script>

  





  
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>




<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/gitalk@1.7.2/dist/gitalk.css" integrity="sha256-AJnUHL7dBv6PGaeyPQJcgQPDjt/Hn/PvYZde1iqfp8U=" crossorigin="anonymous">

<script class="next-config" data-name="gitalk" type="application/json">{"enable":true,"github_id":"pangwong","repo":"pangwong.github.io","client_id":"c3a7ca3ecf4f08f74acb","client_secret":"db3623e99a388c18ba10413186f9051a35cb6627","admin_user":"pangwong","distraction_free_mode":true,"proxy":"https://cors-anywhere.azm.workers.dev/https://github.com/login/oauth/access_token","language":null,"js":{"url":"https://cdn.jsdelivr.net/npm/gitalk@1.7.2/dist/gitalk.min.js","integrity":"sha256-Pmj85ojLaPOWwRtlMJwmezB/Qg8BzvJp5eTzvXaYAfA="},"path_md5":"e2ddf6823fa290d731463db2117dd664"}</script>
<script src="/js/third-party/comments/gitalk.js"></script>

</body>
</html>

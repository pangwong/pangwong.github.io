<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222"><meta name="generator" content="Hexo 6.2.0">

<link rel="preconnect" href="https://fonts.lug.ustc.edu.cn" crossorigin>
<link rel="preconnect" href="https://cdn.jsdelivr.net" crossorigin>
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16.png">
  <link rel="mask-icon" href="/images/safari-pinned-tab.svg" color="#222">
  <link rel="manifest" href="/images/site.webmanifest">

<link rel="stylesheet" href="/css/main.css">

<link rel="stylesheet" href="https://fonts.lug.ustc.edu.cn/css?family=Noto+Serif+SC:300,300italic,400,400italic,700,700italic%7CSF+Mono+Regular:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext">

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6.1.1/css/all.min.css" integrity="sha256-DfWjNxDkM94fVBWx1H5BMMp0Zq7luBlV8QRcSES7s+0=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/animate.css@3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"pangwong.github.io","root":"/","images":"/images","scheme":"Mist","darkmode":false,"version":"8.11.1","exturl":false,"sidebar":{"position":"right","display":"post","padding":18,"offset":12},"copycode":true,"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":true,"lazyload":true,"pangu":true,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"}}</script><script src="/js/config.js"></script>

    <meta name="description" content="Object Oriented Programming">
<meta property="og:type" content="article">
<meta property="og:title" content="Reading Note of CppPrimer-Chapter15">
<meta property="og:url" content="https://pangwong.github.io/blog/2022/06/cpp-primer-chapter15/index.html">
<meta property="og:site_name" content="曰悦鸟">
<meta property="og:description" content="Object Oriented Programming">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://pangwong.github.io/images/blog/chapter15/ch15-access-level.png">
<meta property="article:published_time" content="2022-06-18T10:47:45.000Z">
<meta property="article:modified_time" content="2022-06-20T08:59:51.516Z">
<meta property="article:author" content="PangWong">
<meta property="article:tag" content="reading notes">
<meta property="article:tag" content="cpp-primer">
<meta property="article:tag" content="base class">
<meta property="article:tag" content="derived class">
<meta property="article:tag" content="inheritance">
<meta property="article:tag" content="public&#x2F;protected&#x2F;private">
<meta property="article:tag" content="override">
<meta property="article:tag" content="final">
<meta property="article:tag" content="dynamic binding">
<meta property="article:tag" content="virtual function">
<meta property="article:tag" content="slice down">
<meta property="article:tag" content="pure virtual function">
<meta property="article:tag" content="abstract base class">
<meta property="article:tag" content="member hidden">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://pangwong.github.io/images/blog/chapter15/ch15-access-level.png">


<link rel="canonical" href="https://pangwong.github.io/blog/2022/06/cpp-primer-chapter15/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"zh-CN","comments":true,"permalink":"https://pangwong.github.io/blog/2022/06/cpp-primer-chapter15/","path":"/blog/2022/06/cpp-primer-chapter15/","title":"Reading Note of CppPrimer-Chapter15"}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>Reading Note of CppPrimer-Chapter15 | 曰悦鸟</title>
  





  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <p class="site-title">曰悦鸟</p>
      <i class="logo-line"></i>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a></li><li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a></li>
  </ul>
</nav>




</div>
        
  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>

  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
            <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#Object-Oriented-Programming"><span class="nav-number">1.</span> <span class="nav-text">Object Oriented Programming</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#OOP-Overview"><span class="nav-number">1.1.</span> <span class="nav-text">OOP Overview</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Base-Class-amp-Derived-Class"><span class="nav-number">1.2.</span> <span class="nav-text">Base Class &amp; Derived Class</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Virtual-Functions"><span class="nav-number">1.3.</span> <span class="nav-text">Virtual Functions</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Abstract-Base-Classes"><span class="nav-number">1.4.</span> <span class="nav-text">Abstract Base Classes</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Access-Control-and-Inheritance"><span class="nav-number">1.5.</span> <span class="nav-text">Access Control and Inheritance</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Class-Scope-under-Inheritance"><span class="nav-number">1.6.</span> <span class="nav-text">Class Scope under Inheritance</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Constructor-and-Copy-Control-under-Inheritance"><span class="nav-number">1.7.</span> <span class="nav-text">Constructor and Copy Control under Inheritance</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Container-and-Inheritance"><span class="nav-number">1.8.</span> <span class="nav-text">Container and Inheritance</span></a></li></ol></li></ol></div>
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author site-overview-item animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="PangWong"
      src="/images/avatar.png">
  <p class="site-author-name" itemprop="name">PangWong</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap site-overview-item animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">15</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/categories/">
        <span class="site-state-item-count">1</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/tags/">
        <span class="site-state-item-count">133</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author site-overview-item animated">
      <span class="links-of-author-item">
        <a href="https://github.com/pangwong" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;pangwong" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
  </div>



        </div>
      </div>
    </div>
  </aside>
  <div class="sidebar-dimmer"></div>


    </header>

    
  <div class="back-to-top" role="button" aria-label="返回顶部">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>
  <div class="reading-progress-bar"></div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


    <div class="main-inner post posts-expand">


  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://pangwong.github.io/blog/2022/06/cpp-primer-chapter15/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="PangWong">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="曰悦鸟">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="Reading Note of CppPrimer-Chapter15 | 曰悦鸟">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          Reading Note of CppPrimer-Chapter15
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2022-06-18 18:47:45" itemprop="dateCreated datePublished" datetime="2022-06-18T18:47:45+08:00">2022-06-18</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2022-06-20 16:59:51" itemprop="dateModified" datetime="2022-06-20T16:59:51+08:00">2022-06-20</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/C/" itemprop="url" rel="index"><span itemprop="name">C++</span></a>
        </span>
    </span>

  
    <span class="post-meta-item" title="阅读次数" id="busuanzi_container_page_pv">
      <span class="post-meta-item-icon">
        <i class="far fa-eye"></i>
      </span>
      <span class="post-meta-item-text">阅读次数：</span>
      <span id="busuanzi_value_page_pv"></span>
    </span>
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>20k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>18 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
        <h2 id="Object-Oriented-Programming"><a href="#Object-Oriented-Programming" class="headerlink" title="Object Oriented Programming"></a>Object Oriented Programming</h2><span id="more"></span>



<h3 id="OOP-Overview"><a href="#OOP-Overview" class="headerlink" title="OOP Overview"></a>OOP Overview</h3><ul>
<li>面向对象的程序设计基于三个基本概念：数据抽象(封装)、继承、动态绑定。<ol>
<li>通过<strong>数据抽象</strong>，可以实现将类的接口和实现分离</li>
<li>使用<strong>继承</strong>，可以定义相似的类型并对其相似关系建模</li>
<li><strong>动态绑定</strong>，可以在一定程度上忽略相似类型的区别，而一统一的方式使用它们</li>
</ol>
</li>
</ul>
<h3 id="Base-Class-amp-Derived-Class"><a href="#Base-Class-amp-Derived-Class" class="headerlink" title="Base Class &amp; Derived Class"></a>Base Class &amp; Derived Class</h3><ul>
<li><p>派生类列表(<em>class derivation list</em>)</p>
<p>首先是一个冒号<code>:</code>，后面紧跟以<strong>逗号分隔</strong>的<strong>基类列表</strong>，其中每个基类前面可以有以下三种<strong>访问说明符</strong>(<em>access specifier</em>)中的一种：</p>
<ul>
<li><strong>public</strong></li>
<li><strong>protected</strong></li>
<li><strong>private</strong></li>
</ul>
<p> 值得注意的是，当<strong>声明</strong>一个派生类的时候，<strong>不需要包含他的派生列表</strong></p>
 <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Derived</span>;                 <span class="comment">// correct, declare a derived class</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derived</span> : <span class="keyword">public</span> Base;   <span class="comment">// error</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>派生类经常(但不总是)覆盖(<em>overwrite</em>)他继承的虚函数；</p>
<ul>
<li>如果派生类<strong>没有覆盖其基类中的某个虚函数</strong>，则该函数的<strong>行为类似于普通函数</strong>，派生类会直接继承基类中的这个虚函数；</li>
<li>当然派生类也<strong>可以覆盖他的普通成员函数(非虚函数)</strong></li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span></span>&#123;std:: cout &lt;&lt; <span class="string">&quot;base func&quot;</span> &lt;&lt; std::endl;&#125;;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">func1</span><span class="params">()</span></span>&#123;std:: cout &lt;&lt; <span class="string">&quot;virtual base func1&quot;</span> &lt;&lt; std::endl;&#125;;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">func2</span><span class="params">()</span></span>&#123;std:: cout &lt;&lt; <span class="string">&quot;virtual base func2&quot;</span> &lt;&lt; std::endl;&#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derived</span> : <span class="keyword">public</span> Base&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// override non-virtual member function</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span></span>&#123;std:: cout &lt;&lt; <span class="string">&quot;derived func&quot;</span> &lt;&lt; std::endl;&#125;;</span><br><span class="line">    <span class="comment">// override virtual function</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">func1</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123;std:: cout &lt;&lt; <span class="string">&quot;virtual derived func1&quot;</span> &lt;&lt; std::endl;&#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Derived d;</span><br><span class="line">d.<span class="built_in">func</span>();    <span class="comment">// derived func</span></span><br><span class="line">d.<span class="built_in">func1</span>();   <span class="comment">// virtual derived func1</span></span><br><span class="line">d.<span class="built_in">func2</span>();   <span class="comment">// virtual base func2</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>override</strong>关键字</p>
<p>  C++11新标准允许派生类<strong>显式的注明</strong>他使用某个成员函数<strong>覆盖(<em>overwrite</em>)掉</strong>了他继承的<strong>虚函数</strong></p>
<p>  在<strong>参数列表后</strong>或者const成员函数的<strong>const之后</strong>加上一个<strong>override</strong>关键字，这样可以减少很多出乎意料的bug，比如本来想重写虚函数但是写错了参数列表导致基类虚函数被隐藏而通过动态绑定调用虚函数失败；</p>
<blockquote>
<p><strong>only virtual member functions can be marked as override</strong></p>
</blockquote>
  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">BaseClass</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">int</span> <span class="title">sum</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">int</span> <span class="title">print</span><span class="params">(<span class="type">int</span> a)</span> <span class="type">const</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">DerivedClass</span> : <span class="keyword">public</span> BaseClass&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">sum</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> <span class="keyword">override</span></span>; </span><br><span class="line">    <span class="comment">// int sum(float a, float b) override;  // error, override failed, parameters not match</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">print</span><span class="params">(<span class="type">int</span> a)</span> <span class="type">const</span> <span class="keyword">override</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
<li><p>派生类构造函数</p>
<p>  尽管派生类对象中有从基类继承而来的成员，但是<strong>派生类并不直接初始化基类的成员</strong>，派生类必须<strong>使用基类的构造函数来初始化</strong>他的<strong>基类</strong>部分</p>
<blockquote>
<p>遵循类的接口，每个类控制他自己的成员初始化</p>
<p>尽管在语法上说，我们可以在派生类的构造函数体内给基类的成员赋值来实现基类成员的初始化，但是最好不要这么做。因为每个类都有自己的接口，<strong>和类交互的时候必须使用类的接口</strong>，即使这个类是派生类的基类；</p>
</blockquote>
<p>  除非特别指出，否则派生类对象的基类部分会像数据成员一样执行<strong>默认初始化</strong>；派生类构造函数的初始化部分，<strong>先初始化基类</strong>，然后再<strong>按成员声明的顺序依次初始化自己的数据成员</strong>，再<strong>然后才执行构造函数体</strong>；</p>
  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">BulkQuote</span> : <span class="keyword">public</span> Quote&#123;</span><br><span class="line">    <span class="built_in">BulkQuote</span>(<span class="type">const</span> std::string&amp; book, <span class="type">double</span> p, std::<span class="type">size_t</span> qty, <span class="type">double</span> disc):</span><br><span class="line">        <span class="built_in">Quote</span>(book, p), <span class="built_in">min_qty</span>(qyt), <span class="built_in">discount</span>(disc)&#123;</span><br><span class="line">        <span class="comment">// body of constructor        </span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;; </span><br></pre></td></tr></table></figure>
</li>
<li><p>静态成员的继承</p>
<p>  如果基类定义了一个静态成员，则在<strong>整个继承体系里面都只存在这一个静态成员的唯一定义</strong>；静态成员<strong>遵循通用的访问控制</strong>；调用静态函数的时候可以通过<strong>基类</strong>或者<strong>派生类</strong>的<strong>对象和域作用符</strong>(<em>scope resolution operator</em>)；</p>
  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">static_method</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> val = <span class="number">0</span>;   <span class="comment">// same access method with function</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derived</span> : <span class="keyword">public</span> Base&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(<span class="type">const</span> Derived&amp; derived_obj)</span></span>&#123;</span><br><span class="line">        Base::<span class="built_in">static_method</span>();             <span class="comment">// access via Base via using scope resolution operator</span></span><br><span class="line">        Derived::<span class="built_in">static_method</span>();          <span class="comment">// access via Derived</span></span><br><span class="line">        derived_obj.<span class="built_in">static_method</span>();       <span class="comment">// assess via Derived Object</span></span><br><span class="line">        <span class="built_in">static_method</span>():                   <span class="comment">// access via this pointer</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
<li><p>被用作基类的类</p>
<p>  如果我们希望某个类作为基类，则在<strong>继承他之前，必须有他的定义</strong>，而<strong>不仅仅是声明</strong>；</p>
<ul>
<li>这是因为在派生类继承这个类的时候，派生类要知道自己继承基类的哪些非静态数据成员与函数；</li>
<li>另外一层含义是一个类不能自己继承自己</li>
</ul>
  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Quote</span>;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">BuldQuote</span> : Quote&#123;...&#125;;    <span class="comment">// error, Quote should be defined before being inherited</span></span><br></pre></td></tr></table></figure>

<p>  一个类是基类，同时也可以是派生类</p>
  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span> &#123;&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">D1</span> : <span class="keyword">public</span> Base &#123;&#125;;    <span class="comment">// D1 is base class of D2 and D1 is also a derived class derived from Base</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">D2</span> : <span class="keyword">public</span> D1 &#123;&#125;;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>final</strong>关键字</p>
<p> 如果<strong>不希望一个类作为基类来被继承</strong>，可以在**类名后加上一个<code>final</code>**关键字；</p>
<p>  如果<strong>不希望一个虚函数被重写</strong>，也可以在**虚函数的参数列表后使用<code>final</code>**关键字；</p>
  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">NoDerived</span> <span class="keyword">final</span>&#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">BaseClass</span> &#123;</span><br><span class="line"><span class="keyword">public</span>: </span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">print</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">final</span></span>;   <span class="comment">// cannot be overrided by derived classes </span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">int</span> <span class="title">sum</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>静态类型</strong>(<em>static type</em>) vs <strong>动态类型</strong>(<em>dynamic type</em>)</p>
<ul>
<li><p>静态类型是在<strong>编译时</strong>确定的，动态类型是<strong>运行时</strong>才能确定的；<strong>动态类型是为动态绑定为生</strong></p>
</li>
<li><p>对于派生类和基类来说，一个<strong>指向基类的指针</strong>或者<strong>绑定基类的引用</strong>，他的<strong>静态类型与动态类型可能不一样</strong>；比如<strong>动态绑定</strong>，把一个派生类的对象传递给基类引用或者指针的对象<code>base_obj</code>，这时<code>base_obj</code>的静态类型是基类，但是动态类型是派生类</p>
</li>
<li><p>对于<strong>非基类的引用或者指针</strong>的变量或者表达式，以及基类的<strong>非引用非指针对象</strong>，其<strong>动态类型和静态类型一致</strong>；</p>
</li>
</ul>
</li>
<li><p>派生类到基类的<strong>隐式转换</strong></p>
<p> 和其他类型一样，编译器会<strong>隐式的执行派生类到基类的转换</strong>，这是因为<strong>基类是派生类的子集</strong>；这种特效，意味着我们可以<strong>把派生类对象当作基类对象</strong>使用，<strong>将基类的指针或者引用绑定到派生类的对象</strong>上去；</p>
<p> 派生类到基类的自动转换<strong>仅限于引用和指针</strong>；</p>
<p> 我们可以将派生类的对象绑定到基类的引用或者指向基类的指针，但是<strong>不存在从基类到派生类的自动类型转换，即使一个基类指针或者引用绑定的是一个派生类</strong></p>
 <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">BaseClass item1;</span><br><span class="line">DerivedClass item2;</span><br><span class="line"></span><br><span class="line">BaseClass *p = &amp;item1;        </span><br><span class="line">p = &amp;item2;              <span class="comment">// implicit conversion of pointer</span></span><br><span class="line">BaseClass &amp;r = item2;    <span class="comment">// implicit conversion of reference</span></span><br><span class="line">item1 = item2;           <span class="comment">// implicit conversion of normal object</span></span><br><span class="line"></span><br><span class="line">BaseClass sb = item2;    <span class="comment">// not convert, but sliced derived class</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>通常情况下，要把引用或指针绑定到一个对象上，那么引用或指针的类型需要和对象的类型一致，或者存在可转换的const类型</p>
<p>但是<strong>存在继承关系的类是一个例外：这是因为动态绑定的存在，我们并不知道引用绑定或者指针指向的对象到底是基类的类型还是派生类的类型</strong>；</p>
</blockquote>
<p> 和内置指针类似，<strong>智能指针</strong>也支持派生类向基类指针的<strong>自动转换</strong>；</p>
 <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> BaseClass&amp; a = <span class="built_in">DerivedClass</span>();</span><br><span class="line">std::shared_ptr&lt;BaseClass&gt; p = std::<span class="built_in">make_shared</span>&lt;DerivedClass&gt;();</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>slice down</strong></p>
<p> 尽管派生类到基类的隐式转换只应用于<code>reference</code>和<code>pointer</code>，但是因为类的拷贝控制操作的存在，使得<strong>直接将派生类的对象拷贝赋值或者移动赋值给基类对象是可能的</strong>，但是会有意想不到的结果，即<strong>仅会拷贝基类的部分</strong>(<em>slice down</em>)；</p>
<blockquote>
<p>TLDR: 因为<strong>构造函数不能是虚函数</strong>，<strong>没有动态绑定</strong>，所以拷贝&#x2F;移动构造&#x2F;赋值函数的参数为基类的引用，是一个<strong>静态类型</strong></p>
<p>比如类的拷贝构造&#x2F;赋值函数操作符接受<strong>const reference</strong>作为参数，所以<strong>派生类向基类的转换</strong>允许我们给基类的拷贝&#x2F;赋值操作传递一个派生类对象；但是因为<strong>这些函数不是<code>virtual</code>的</strong>，所以将一个派生类赋值给一个基类<strong>不涉及动态绑定</strong>；这些函数只认参数的静态类型，即基类类型，而不知道传递的参数是派生类类型；<strong>因此只有基类的部分会被拷贝，派生类的部分被丢弃</strong>；</p>
</blockquote>
 <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// slice down: only baseclass parts are copied, derived parts are not copied</span></span><br><span class="line">DerivedClass derived;</span><br><span class="line"><span class="function">BaseClass <span class="title">base</span><span class="params">(derived)</span></span>;          <span class="comment">// copy constructor of BaseClass, derived converted to BaseClass implicitly</span></span><br><span class="line">BaseClass base1 = derived;        <span class="comment">// assignment operator</span></span><br><span class="line">BaseClass&amp; moved_obj = std::<span class="built_in">move</span>(derived);    <span class="comment">// move constructor of BaseClass</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>不能隐式地</strong>把基类对象转换为派生类对象；但是可以通过<code>dynamic_cast</code>或者<code>static_cast</code>等强制转换来实现</p>
<ol>
<li><strong>基类到派生类的转换仅限于引用和指针</strong>；</li>
<li>如果基类有一个或者多个虚函数，则使用<code>dynamic_cast</code>来转换，他会在运行时动态转换，如果转换不合法<strong>返回空指针</strong>或者<strong>抛出<code>std::bad_cast</code>异常</strong>;参见chapter4</li>
<li>如果我们已知转换是安全的，即已知基类的引用和指针确实<strong>是指向派生类的对象</strong>的时候，直接使用<code>static_cast</code>让编译器强制转换即可；</li>
</ol>
 <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">BaseClass obj = <span class="built_in">DerivedClass</span>();   <span class="comment">// valid, slice down</span></span><br><span class="line">DerivedClass obj = <span class="built_in">BaseClass</span>();   <span class="comment">// invalid, no such conversion</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="Virtual-Functions"><a href="#Virtual-Functions" class="headerlink" title="Virtual Functions"></a>Virtual Functions</h3><ul>
<li><p>在C++中，基类必须将他的两种成员函数区分开</p>
<ul>
<li>一种是希望派生类进行覆盖（<em>override</em>）的函数，此时基类应当把这些函数声明为虚函数(<em>virtual function</em>)；</li>
<li>另一种是希望派生类直接继承使用而<strong>不做改变的</strong></li>
</ul>
</li>
<li><p><strong>虚函数</strong>(<em>virtual function</em>)</p>
<p>  通过在其成员函数的声明语句之前加上<code>virtual</code>关键字将函数声明为虚函数</p>
<ul>
<li>任何构造函数之外的<strong>非静态函数</strong>都可以是虚函数；</li>
<li><code>virtual</code>关键字<strong>只能出现在类内的函数声明之前</strong>，而<strong>不能出现在类外的定义之前</strong></li>
<li>一般的成员函数如果没有使用可以不定义，但是<strong>虚函数不管用与不用都得定义</strong>，因为其解析发生在运行时，并不知道会调用哪个函数</li>
<li>一旦基类中某个函数被标记为<code>virtual</code>后，他的所有派生类的这个函数都自动是<code>virtual</code>的；派生类不必一直重复写<code>virtual</code>关键字；</li>
<li>派生类里面对此虚函数的重写应当满足<strong>参数列表</strong>和<strong>返回值相同</strong>的要求；返回值有一个意外，即如果基类的<code>virutal</code>函数<strong>返回基类的引用或者指针</strong>，派生类也可以<strong>返回派生类的引用和指针</strong>，此时会涉及<strong>自动转换</strong>；</li>
</ul>
</li>
<li><p>动态绑定(<em>dynamic binding</em>)</p>
<p>  当我们使用基类的<code>引用</code> 或者 <code>指针</code> <strong>调用一个虚函数</strong>时将发生<strong>动态绑定</strong>，即在运行时选择函数版本，也叫运行时绑定(<em>runtime binding</em>)；基类通过在函数前加上<code>virtual</code>关键字，使得该函数执行动态绑定；注意：只有<strong>引用和指针</strong>+<strong>虚函数</strong>可以实现<strong>动态绑定</strong></p>
<p>  类的<strong>非虚成员</strong>函数是<strong>静态绑定</strong>，在编译的时候就能确定。</p>
<blockquote>
<p>In C++, dynamic binding happens when a <strong>virtual function</strong> is called through a <strong>reference</strong> (or a <strong>pointer</strong>) to a base class.</p>
</blockquote>
  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Quote</span>&#123;</span><br><span class="line">      <span class="function"><span class="keyword">virtual</span> <span class="type">double</span> <span class="title">price</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">BulkQuote</span> : <span class="keyword">public</span> Quote&#123;</span><br><span class="line">      <span class="function"><span class="keyword">virtual</span> <span class="type">double</span> <span class="title">price</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">print_total</span><span class="params">(<span class="type">const</span> Quote&amp;item)</span></span>&#123;</span><br><span class="line">      std::cout &lt;&lt; item.<span class="built_in">price</span>() &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Quote quote;</span><br><span class="line">BulkQuote bulk;</span><br><span class="line"><span class="comment">// dynamic binding</span></span><br><span class="line"><span class="built_in">print_total</span>(quote);   <span class="comment">// call Quote::price()</span></span><br><span class="line"><span class="built_in">print_total</span>(bulk);    <span class="comment">// call BulkQuote::price()</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>绕过动态绑定</p>
<p>  可以显式的<strong>绕过动态绑定</strong>来调用特定版本的虚函数：通过<strong>域作用符</strong>来实现，此时编译器会在编译时解析；</p>
<p>  最常见的场景是在<strong>派生类或者派生类的友元函数里面调用基类的虚函数</strong>；如果不加域作用符，会出现自己调用自己的<strong>递归死循环</strong>；</p>
  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// call BaseClass::virtual_function or DerivedClass::virtual_function depend on dynamic type of baseP</span></span><br><span class="line">baseP-&gt;<span class="built_in">virtual_function</span>();        </span><br><span class="line"></span><br><span class="line"><span class="comment">// call the version from base class regardless of the dynamic type of baseP</span></span><br><span class="line">baseP-&gt;BaseClass::<span class="built_in">virtual_function</span>();</span><br><span class="line"></span><br><span class="line">DerivedClass::<span class="built_in">virtual_func</span>()&#123;</span><br><span class="line">    BaseClass:<span class="built_in">virtual_func</span>();     <span class="comment">// call base class version virtual func firstly</span></span><br><span class="line">    <span class="built_in">virtual_func</span>();               <span class="comment">// WARNING: infinite loop</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">A</span>()=<span class="keyword">default</span>;</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">A</span>()=<span class="keyword">default</span>;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">int</span> i = <span class="number">10</span>)</span></span>&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;A=%d\n&quot;</span>,i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> :<span class="keyword">public</span> A&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">B</span>()=<span class="keyword">default</span>;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">int</span> i = <span class="number">20</span>)</span></span>&#123;</span><br><span class="line">        A::<span class="built_in">func</span>();           <span class="comment">//在派生类中调用基类的版本</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;B=%d\n&quot;</span>, i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// test code</span></span><br><span class="line">B b1;</span><br><span class="line">A* p1 = &amp;b1;</span><br><span class="line">B* p2 = &amp;b1;</span><br><span class="line"> </span><br><span class="line">p1-&gt;A::<span class="built_in">func</span>();   <span class="comment">// print A=10, 虽然p1指向的是派生类实例，但是通过作用域限制，要求其调用基类的版本</span></span><br><span class="line">p2-&gt;<span class="built_in">func</span>();      <span class="comment">// print A=10\nB=1\n, 虽然p2是派生类指针，但是派生类的虚函数实现中，会先调用基类的实现</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// reference：https://blog.csdn.net/ykun089/article/details/106985934</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>虚函数的<strong>默认参数</strong>问题</p>
<p>  如果基类的虚函数有默认参数，则派生类里面的虚函数<strong>要么定义的默认参数和基类一致，要么都不定义默认参数</strong>；否则会出现意想不到的结果；如果某次调用过程中使用了默认参数，则<strong>该实参值由本次调用的静态类型决定</strong>；</p>
<ul>
<li><p>基类和子类都没有默认参数的时候，<strong>正常发生多态</strong></p>
</li>
<li><p><strong>基类和子类都有默认参数的时候且默认参数不一致的时候</strong>，或者<strong>基类子类参数列表一致且基类有默认参数而子类没有默认参数</strong>的时候，派生类继承基类的默认参数</p>
<blockquote>
<p>基类中虚函数的<strong>默认参数会在编译过程就被保存</strong>，再调用子类的函数后发生多态，<strong>编译器会使用基类的默认参数</strong>，这是因为是<strong>实参值由静态类型决定</strong>，而此时的静态类型是基类的指针或引用</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">int</span> i = <span class="number">10</span>)</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Base&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;   </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derived</span> : <span class="keyword">public</span> Base &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 基类和子类都有默认参数的时候且默认参数不一致的时候</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">int</span> i = <span class="number">0</span>)</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Derived: &quot;</span> &lt;&lt; i &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 基类子类参数列表一致且基类有默认参数而子类没有默认参数，此函数依然覆盖的是 Base 中的 func 函数</span></span><br><span class="line">    <span class="comment">// void func(int i) &#123;</span></span><br><span class="line">    <span class="comment">//   std::cout &lt;&lt; &quot;Derived: &quot; &lt;&lt; i &lt;&lt; std::endl;</span></span><br><span class="line">    <span class="comment">// &#125;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Base *p = <span class="keyword">new</span> Derived;</span><br><span class="line">p-&gt;<span class="built_in">func</span>();            <span class="comment">// print &quot;Derived 10&quot;, 10 is the default parameter inherited from base class</span></span><br><span class="line">p-&gt;<span class="built_in">func</span>(<span class="number">1</span>);           <span class="comment">// print &quot;Derived 1&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//reference: https://blog.csdn.net/weixin_44720401/article/details/106745426</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>基类子类参数列表一致且子类有默认参数而基类没有默认参数</strong>，此时<strong>无法使用</strong>基类调用虚函数且<strong>使用子类虚函数的默认参数</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Base</span>&#123;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Base: &quot;</span> &lt;&lt; a &lt;&lt; b &lt;&lt; std::endl;</span><br><span class="line">    &#125; </span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Derived</span> : <span class="keyword">public</span> Base&#123;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b=<span class="number">1</span>)</span></span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Derived: &quot;</span> &lt;&lt; a &lt;&lt; b &lt;&lt; std::endl;</span><br><span class="line">    &#125; </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Derived d;</span><br><span class="line">Base&amp; b =  d;</span><br><span class="line">b.<span class="built_in">func</span>(<span class="number">1</span>);  <span class="comment">// error: too few arguments to function call, expected 2, have 1</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>基类有(默认)参数而子类没有参数(no parameters)<strong>，则该函数 <code>func</code> 函数是</strong>子类</strong>(<em>derived class</em>)中的<strong>新成员</strong>，虚函数没有重写(<em>overwrite</em>)成功</p>
<p>因为参数数量不一样，子类中定义的<strong>没有参数的</strong> <code>func</code> 函数并不是从基类中继承而来，但是子类依旧继承了基类中<strong>有参数的</strong> <code>func</code> 函数，所以用<strong>基类指针</strong>调用<strong>有参数的</strong><code>func</code> 函数<strong>会发生多态</strong>，而用<strong>子类指针</strong>调用的<strong>没有参数的</strong><code>func</code>函数才是<strong>自己定义的</strong>新成员</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">int</span> i = <span class="number">10</span>)</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Base&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;   </span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derived</span> : <span class="keyword">public</span> Base &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Derived&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;   </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Base *p = <span class="keyword">new</span> Derived;</span><br><span class="line">p-&gt;<span class="built_in">func</span>();        <span class="comment">// print Base</span></span><br><span class="line">Derived *q = <span class="keyword">new</span> Derived;</span><br><span class="line">q-&gt;<span class="built_in">func</span>();        <span class="comment">// print Derived</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>子类中有(默认)参数而基类没有参数</strong>，结果和 2 中一样，原因也一样；但要注意如果用父类指针调用 func 函数并传入了参数，编译器会报错，因为父类中 func 的函数没有参数，又因为父类指针不能调用子类的非继承而来的函数，因此没有函数与之匹配。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span> &#123; </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">func</span><span class="params">()</span> </span>&#123; </span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Base&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125; </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derived</span> : <span class="keyword">public</span> Base &#123; </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">int</span> i = <span class="number">10</span>)</span> </span>&#123; </span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Derived&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125; </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Base *p = <span class="keyword">new</span> Derived;</span><br><span class="line">p-&gt;<span class="built_in">func</span>();</span><br><span class="line"><span class="comment">// p-&gt;func(3);// 如果传入参数会报错，因为父类中的 func 的函数没有参数，又因为父类指针不能调用</span></span><br><span class="line">              <span class="comment">// 子类的非继承而来的函数, 因此没有函数与之匹配，所以编译器会报错</span></span><br><span class="line">Derived *q = <span class="keyword">new</span> Derived;</span><br><span class="line">q-&gt;<span class="built_in">func</span>();    <span class="comment">// print &quot;Derived&quot;</span></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<h3 id="Abstract-Base-Classes"><a href="#Abstract-Base-Classes" class="headerlink" title="Abstract Base Classes"></a>Abstract Base Classes</h3><ul>
<li><p>纯虚函数(<em>pure virtual function</em>)</p>
<p> 通过在函数体的位置书写<code>=0</code>就可以把一个虚函数申明为纯虚函数；<code>=0</code><strong>只能出现在类内部的虚函数声明处</strong>；和普通函数不同，一个纯虚函数<strong>不需要定义</strong>；</p>
</li>
<li><p>虚基类</p>
<p> 含有纯虚函数的类是虚基类；虚基类<strong>不能直接实例化</strong>，但是<strong>可以被继承</strong>，在<strong>派生类的构造函数里面可以调用虚基类的构造函数初始化虚基类的成员变量</strong>；</p>
  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">AbstractBaseClass</span> &#123; </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">double</span> <span class="title">pure_virtual_func</span><span class="params">(std::<span class="type">size_t</span>)</span> <span class="type">const</span> </span>= <span class="number">0</span>;    <span class="comment">// pure virtual function</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
<li><p>纯虚函数是<strong>可以在类的外部定义的</strong>（但是这种定义一般来说<strong>没有意义</strong>，因为派生类都会重写纯虚函数），<strong>不能在类内声明纯虚函数的时候提供函数体</strong>；</p>
 <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// in .cpp file</span></span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">AbstractBaseClass::pure_virtual_func</span><span class="params">()</span></span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;from pure abstract func&quot;</span> &lt;&lt; std::end;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0.0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="Access-Control-and-Inheritance"><a href="#Access-Control-and-Inheritance" class="headerlink" title="Access Control and Inheritance"></a>Access Control and Inheritance</h3><ul>
<li><p><strong>protected</strong>关键字</p>
<p>  某些成员，基类希望<strong>派生类</strong>或者<strong>派生类的友元</strong>可以访问，但是<strong>类的用户不可以直接访问</strong>，则可以定义为<code>protected</code>类型；<code>protected</code>说明符可以看作<code>public</code>和<code>private</code>的中和</p>
<ul>
<li><p>和<code>private</code>类似，类的<strong>用户</strong>不可以访问<code>protected</code>成员</p>
</li>
<li><p>和<code>public</code>类似，<strong>派生类及其友元</strong>可以访问<code>protected</code>成员</p>
</li>
<li><p>派生类的成员或者友元只能<strong>通过派生类对象</strong>来<strong>访问基类</strong>的<code>protected</code>成员，无法<strong>通过基类</strong>直接<strong>访问基类</strong>中的<code>protected</code>成员；</p>
</li>
</ul>
   <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">BaseClass</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">BaseClass</span>();</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="type">int</span> member_protected;  <span class="comment">// can be accessed from derived class, but not class user</span></span><br><span class="line"><span class="keyword">private</span>: </span><br><span class="line">    <span class="type">int</span> member_private;    <span class="comment">// can not be accessed from both derived class and class user</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Sneaky</span> : <span class="keyword">public</span> BaseClass&#123;</span><br><span class="line">    <span class="function"><span class="keyword">friend</span> <span class="type">void</span> <span class="title">clobber</span><span class="params">(Sneaky&amp;)</span></span>;      <span class="comment">// 可以通过Sneaky访问BaseClass::member_protected</span></span><br><span class="line">    <span class="function"><span class="keyword">friend</span> <span class="type">void</span> <span class="title">clobber</span><span class="params">(BaseClass&amp;)</span></span>;   <span class="comment">// 不可以通过BaseClass直接访问BaseClass::member_protected，以上第三条</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
<li><p>类成员的用户可以大概分为3级：</p>
<ul>
<li>1级用户：类内访问(类的实现者，如类的成员函数，友元)，可以访问<strong>所有<code>public</code>,<code>protected</code>,<code>private</code>成员</strong></li>
<li>2级用户：子类，<strong>根据继承方式的不同</strong>，可以分别访问所有的**<code>public</code>,<code>protected</code>成员**</li>
<li>3级用户：类和子类的用户(可以理解成通过类的实例化对象来访问，即类的普通用户)，<strong>只能访问<code>public</code>的成员</strong></li>
</ul>
</li>
<li><p><strong>继承派生说明符</strong>(<em>derivation access specifier</em>)</p>
<p>  C++的继承派生说明符（<code>public</code>、<code>private</code>、<code>protected</code>）会影响<strong>子类的对外访问属性</strong>，判断某一句话能否被访问：</p>
<ol>
<li>看<strong>调用语句</strong>，看这句话写在子类的内部（类&#x2F;子类内访问）、外部（类&#x2F;子类的用户）</li>
<li>看子类<strong>如何从父类继承</strong>（<code>public</code>、<code>private</code>、<code>protected</code>） </li>
<li>看<strong>父类中的访问级别</strong>（<code>public</code>、<code>private</code>、<code>protected</code>）</li>
</ol>
<p>  <img data-src="/images/blog/chapter15/ch15-access-level.png" alt="ch15-access-level"></p>
<p>  即访问派生说明符<strong>只影响类的用户对类成员的访问权限</strong>；对于子类的用户来说，只能访问<strong>访问说明符为<code>public</code>的成员</strong></p>
<p>  访问派生说明符<strong>对于派生类的成员（及友元）能否访问其直接的基类成员没有什么影响</strong>；父类的<strong>公有成员<code>public</code>和保护成员<code>protected</code></strong> 由于继承方式不同，在子类中的<strong>访问说明符</strong>(<em>access specifier</em>)也不同，但是<strong>不管是继承下来后属于哪类访问说明符，在子类的内部，这些成员（<code>public</code>, <code>protected</code>）都能被访问</strong>；<code>private</code>成员不论是<strong>子类还是用户均不可以访问</strong></p>
</li>
<li><p><code>class</code> and <code>struct</code> 默认继承派生说明符</p>
<ul>
<li><code>class</code>默认私有继承(<code>private</code>)</li>
<li><code>struct</code>默认公有继承(<code>public</code>)</li>
<li>除了默认成员访问符和默认派生访问说明符不同，<code>struct</code>和<code>class</code>没有任何区别</li>
</ul>
</li>
<li><p><strong>友元与继承</strong></p>
<p>  就像<strong>友元关系不能传递一样</strong>，友元关系<strong>同样不能被继承</strong>；每个类负责控制自己的成员权限，<strong>对基类的访问权限由基类本身控制</strong>，即使对于派生类的基类部分也是如此</p>
<p>  <strong>基类的友元</strong>在访问<strong>派生类的成员</strong>时不具有特权；</p>
  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">BaseClass</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">friend</span> <span class="keyword">class</span> <span class="title class_">Pal</span>;</span><br><span class="line">    <span class="built_in">BaseClass</span>();</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="type">int</span> member_protected;   <span class="comment">// can be accessed from derived class, but not class user</span></span><br><span class="line"><span class="keyword">private</span>: </span><br><span class="line">    <span class="type">int</span> member_private;     <span class="comment">// can not be accessed from both derived class and class user</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Sneaky</span> : <span class="keyword">public</span> BaseClass&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> j;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Pal</span> &#123;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">f1</span><span class="params">(BaseClass B)</span></span>&#123;<span class="keyword">return</span> B.member_protected;&#125;   <span class="comment">// valid, Pal is friend class of BaseClass</span></span><br><span class="line">    <span class="comment">//int f2(Sneaky S)&#123;return S.j;&#125;                   // invalid, Pal is not a friend class of Sneaky</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 对基类的访问权限由基类本身控制，即使对于派生类的基类部分也是如此</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">f3</span><span class="params">(Sneaky S)</span></span>&#123;<span class="keyword">return</span> S.member_protected;&#125;      <span class="comment">// valid, Pal is friend class of BaseClass</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">f4</span><span class="params">(Sneaky S)</span></span>&#123;<span class="keyword">return</span> S.member_private;&#125;        <span class="comment">// valid, Pal is friend class of BaseClass</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>  <strong>派生类的友元</strong>访问<strong>基类的成员</strong>时也没有特权</p>
  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">BaseClass</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">BaseClass</span>();</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="type">int</span> member_protected;   <span class="comment">// can be accessed from derived class, but not class user</span></span><br><span class="line"><span class="keyword">private</span>: </span><br><span class="line">    <span class="type">int</span> member_private;     <span class="comment">// can not be accessed from both derived class and class user</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Sneaky</span> : <span class="keyword">public</span> BaseClass&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">friend</span> <span class="keyword">class</span> <span class="title class_">Pal</span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> j;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Pal</span> &#123;</span><br><span class="line">    <span class="comment">//int f1(BaseClass B)&#123;return B.member_protected;&#125; // invalid, Pal is not a friend class of Sneaky</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">f2</span><span class="params">(Sneaky S)</span></span>&#123;<span class="keyword">return</span> S.j;&#125;                     <span class="comment">// valid, Pal is friend class of BaseClass</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
<li><p>可以使用<code>using</code>声明<strong>改变个别成员的访问级别</strong>；派生类<strong>只能对那些可以访问的成员使用using声明</strong></p>
  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span>&#123;</span><br><span class="line"><span class="keyword">public</span>: </span><br><span class="line">    <span class="function">std::<span class="type">size_t</span> <span class="title">size</span><span class="params">()</span> <span class="type">const</span> </span>&#123;<span class="keyword">return</span> n&#125;;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    std::<span class="type">size_t</span> n = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> j = <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derived</span> : <span class="keyword">private</span> Base&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">using</span> Base::size;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="keyword">using</span> Base::n;        <span class="comment">// 可以这么做是因为Derived的派生类本来就可以访问基类的protected成员</span></span><br><span class="line">    <span class="comment">//using Base::j;      // error: &#x27;j&#x27; is a private member of &#x27;Base&#x27;，派生类不可以访问基类的private成员</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Derived d;</span><br><span class="line">std::<span class="type">size_t</span> s = d.<span class="built_in">size</span>(); <span class="comment">// valid</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="Class-Scope-under-Inheritance"><a href="#Class-Scope-under-Inheritance" class="headerlink" title="Class Scope under Inheritance"></a>Class Scope under Inheritance</h3><ul>
<li><p>每个类<strong>定义自己的作用域</strong>，在这个作用域里面我们定义类的成员；</p>
</li>
<li><p>当发生继承的时候，<strong>派生类的作用域嵌套在基类的作用域之内</strong>；正是因为这样的机制，我们才可以<strong>在派生类里面和使用自己的成员一样使用基类的成员</strong>，想象一下在函数体里使用全局变量；</p>
<blockquote>
<p>Base class</p>
<p>int num &#x3D; 0;</p>
<blockquote>
<p>Derived Class</p>
<p>num &#x3D; 1;</p>
</blockquote>
</blockquote>
</li>
<li><p><strong>名字查找</strong>优先于<strong>类型检查</strong></p>
<ul>
<li><p>解析的时候，先从派生类的作用域里面找<strong>相同的成员名字</strong>，找不到就找派生类的上一层基类，一直到最顶层的基类为止；</p>
</li>
<li><p>但凡<strong>找到了名字，就不再继续找了</strong>，哪怕参数列表不一致；然后再<strong>检查参数列表</strong>是否一致；</p>
</li>
</ul>
</li>
<li><p>基类成员数据的隐藏</p>
<p>  和内层的局部变量可以隐藏外层局部变量相似，派生类也能<strong>重新定义</strong>（覆盖隐藏）在其基类中存在的同名成员（函数和变量），此时<strong>派生类定义的新成员将隐藏基类中的同名成员</strong>；</p>
<p>  当然我们可以使用<strong>域作用符(<em>scope resolution operator</em>)直接访问被隐藏的同名成员</strong>（包含数据成员和成员函数）</p>
  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Base</span>(<span class="type">int</span> mem_) : <span class="built_in">mem</span>(mem_)&#123;&#125;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="type">int</span> mem = <span class="number">0</span>;            <span class="comment">// mem of Base</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derived</span> : <span class="keyword">public</span> Base&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Derived</span>(<span class="type">int</span> mem_): <span class="built_in">Base</span>(mem_), <span class="built_in">mem</span>(mem_)&#123;&#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">GetBaseMem</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> Base::mem;&#125;                <span class="comment">// return Base::mem</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">GetMem</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> mem;&#125;                          <span class="comment">// return Derived::men</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> mem = <span class="number">0</span>;            <span class="comment">// mem of Derived, which will hidden mem of Base</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
<li><p>普通成员函数的<strong>重载</strong>(<em>overload</em>)和<strong>隐藏</strong>(<em>hidden</em>)</p>
<p>声明在内层（即派生类）的成员函数和声明在外层（即基类）的成员函数<strong>并不具有重载(<em>overload</em>)的关系</strong>；</p>
<p>内层<strong>同名</strong>的函数或成员会<strong>直接隐藏掉(<em>hidden</em>)<strong>外层的成员，即使函数的</strong>参数列表不一致</strong>，也<strong>不会发生重载</strong>，直接<strong>隐藏</strong>(<em>hidden</em>)；</p>
<p>比如某个基类有多个重载的成员函数，此时派生类仅仅定义一个和基类同名的函数，就可以<strong>隐藏(<em>hidden</em>)掉所有基类的同名函数</strong>；此时如果派生类需要基类的这些重载函数对其可见，<strong>要么一个同名函数也不要定义，要么定义基类所有的重载函数</strong>（可以使用<code>using</code>）</p>
<ul>
<li><code>using</code>关键字可以使得所有在继承过程中<strong>因为各种原因不可见</strong>的成员对于本成员可见，但<strong>前提是本身这些成员在派生类可见</strong><ul>
<li>比如因为<code>private</code>、<code>protected</code>继承导致某些成员不可见的时候</li>
<li>比如因为继承，**派生类把基类的成员隐藏(hidden)**的时候</li>
</ul>
</li>
<li><strong>域作用符</strong>(<em>scope resolution operator</em>)也是很好的工具去直接<strong>访问被隐藏</strong>(<em>hidden</em>)的成员</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Base</span>&#123;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">mem_func</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Derived</span> : <span class="keyword">public</span> Base&#123;</span><br><span class="line">    <span class="comment">// the function hidden mem_func of Base, though the argment list diffs</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">mem_func</span><span class="params">(<span class="type">int</span> i)</span></span>&#123;&#125;;    </span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Derived1</span> : <span class="keyword">public</span> Base&#123;</span><br><span class="line">    <span class="comment">// if using Base::mem_func, the hidden function will be visible to the derived class</span></span><br><span class="line">    <span class="keyword">using</span> Base::mem_func;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// the function hidden mem_func of Base, though the argment list diffs</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">mem_func</span><span class="params">(<span class="type">int</span> i)</span></span>&#123;&#125;;   </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Base b; </span><br><span class="line">Derived d; </span><br><span class="line">Derived1 d1;</span><br><span class="line">b.<span class="built_in">mem_func</span>();          <span class="comment">// valid</span></span><br><span class="line">d.Base::<span class="built_in">mem_func</span>();    <span class="comment">// valid, access via scope resolution operator</span></span><br><span class="line">d.<span class="built_in">mem_func</span>(<span class="number">10</span>);        <span class="comment">// valid</span></span><br><span class="line">d.<span class="built_in">mem_func</span>();          <span class="comment">// invalid, function hidden by int mem_func(int i)&#123;&#125;;   </span></span><br><span class="line">d1.<span class="built_in">mem_func</span>(<span class="number">10</span>);       <span class="comment">// valid</span></span><br><span class="line">d1.<span class="built_in">mem_func</span>();         <span class="comment">// valid, because of the using Base::mem_func</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>虚函数的<strong>重写</strong>(<em>overwrite</em>)和<strong>隐藏</strong>(<em>hidden</em>)</p>
<p>虚函数只有<strong>函数名和参数列表都完全匹配</strong>的情况下<strong>才算重写</strong>(<em><strong>overwrite</strong></em>)，否则<strong>基类的虚函数会被派生类的同名成员函数隐藏掉</strong>(<em><strong>hidden</strong></em>)；</p>
<p>比如某个虚函数，<strong>派生类参数列表和基类的参数列表不一致</strong>，基类的虚函数就会被派生类的普通成员函数<strong>隐藏</strong>(<em><strong>hidden</strong></em>)掉； 此时因为<strong>派生类没有虚函数重写(<em>overwrite</em>)的发生</strong>，派生类并<strong>没有定义自己版本的虚函数</strong>，<strong>也就无法通过基类的引用或者下指针访问派生类自己的虚函数</strong>(因为本身就没有)；这也是为什么我们建议<strong>基类和派生类的虚函数必须具有相同的参数列表</strong>了；</p>
<p>不过，虽然不能通过<strong>基类的引用或指针加上动态绑定</strong>访问<strong>派生类的虚函数</strong>，但是可以使用<strong>基类的引用或指针加上动态绑定</strong>访问<strong>基类的虚函数</strong>；</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Base</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">int</span> <span class="title">fcn</span><span class="params">()</span></span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Base FCN&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Derived</span> : Base&#123;</span><br><span class="line">    <span class="comment">// because fcn is a virtual func, then this function did not overwrite Base::fcn successfully</span></span><br><span class="line">    <span class="comment">// so the Derived class indeed includes 2 fcn functions:</span></span><br><span class="line">    <span class="comment">// 1. Base::fcn() virtual func, which is hidden and can only be accessed by dynamic binding      </span></span><br><span class="line">    <span class="comment">// 2. Derived::fcn(int), normal member func, when we call Derived::fcn ,this one is called</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">fcn</span><span class="params">(<span class="type">int</span> a)</span></span>&#123;</span><br><span class="line">          std::cout &lt;&lt; <span class="string">&quot;Derived FCN&quot;</span> &lt;&lt; std::endl; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Derived1</span> : Derived&#123;</span><br><span class="line">    <span class="comment">// because Derived inherits the defination of virtual func: Base::fcn</span></span><br><span class="line">    <span class="comment">// so this class overwriten the fcn function as a virtual function</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">fcn</span><span class="params">()</span></span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Derived 1 FCN&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Base b;</span><br><span class="line">Derived d;</span><br><span class="line">Derived1 d1;</span><br><span class="line"></span><br><span class="line"><span class="comment">// static bind</span></span><br><span class="line">d.<span class="built_in">fcn</span>(<span class="number">10</span>);      <span class="comment">// valid</span></span><br><span class="line">d.<span class="built_in">fcn</span>();        <span class="comment">// invalid, the func is hidden by int fcn(int)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// dynamic bind</span></span><br><span class="line">Base *bp1 = &amp;b, *bp2 = &amp;d, *bp3 = &amp;d1;</span><br><span class="line">bp1-&gt;<span class="built_in">fcn</span>();     <span class="comment">// Base FCN</span></span><br><span class="line">bp2-&gt;<span class="built_in">fcn</span>();     <span class="comment">// Base FCN</span></span><br><span class="line">bp3-&gt;<span class="built_in">fcn</span>();     <span class="comment">// Derived 1 FCN</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="Constructor-and-Copy-Control-under-Inheritance"><a href="#Constructor-and-Copy-Control-under-Inheritance" class="headerlink" title="Constructor and Copy Control under Inheritance"></a>Constructor and Copy Control under Inheritance</h3><ul>
<li><p>虚析构函数(<em>virtual destructor</em>)</p>
<p>  如果<strong>派生类</strong>定义了一些<strong>需要析构函数释放的资源</strong>，而且<strong>派生类可能会使用动态绑定</strong>（使用基类的引用或者指针来访问），那么<strong>基类的析构函数</strong>需要定义为<strong>虚析构函数</strong>，此时<strong>调用基类的析构函数</strong>的其实是动态绑定后的<strong>派生类的虚构函数</strong>；一般最好都给基类定义一个虚析构函数；</p>
<p>  如果基类的析构函数不是虚析构函数，则<code>delete</code>一个指向派生类的基类的指针会产生未定义的结果；</p>
<blockquote>
<p>假如析构函数不是虚函数，此时使用指向派生类的基类的指针或引用不会发生动态绑定，只会调用基类的析构函数，从而在派生类中分配的资源就无法释放</p>
</blockquote>
  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Quote</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">Quote</span>()&#123;&#125;;               <span class="comment">// 如果一个类定义了析构函数，则他的移动构造/赋值操作将不会被自动合成</span></span><br><span class="line">    <span class="built_in">Quote</span>(Quote&amp;&amp;) = <span class="keyword">default</span>;         <span class="comment">// 如果需要使用移动操作，必须手动定义移动操作</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
<li><p>派生类的合成拷贝控制</p>
<p>  派生类当然也可以自动合成<code>构造</code>、<code>赋值</code>、<code>析构</code>函数；这些合成的成员除了负责对<strong>自己的成员</strong><code>顺序初始化</code>、<code>赋值</code>和<code>销毁</code>外，还负责<strong>调用直接基类的对应函数</strong>（无论是合成的还是自定义的）进行<strong>基类部分</strong>的<code>初始化</code>、<code>赋值</code>和<code>销毁</code>；</p>
<p>  整个过程从作用域的角度来看是<strong>自外向内</strong>的，从继承的角度看是<strong>从基类到派生类</strong>的；</p>
  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">BaseClass</span>&#123;</span><br><span class="line">    <span class="type">int</span> base_num = <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">DerivedA</span> : BaseClass&#123;</span><br><span class="line">    <span class="type">int</span> derived_a_num = <span class="number">1</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">DerivedB</span> : DerivedA&#123;</span><br><span class="line">    <span class="type">int</span> derived_b_num = <span class="number">2</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>  此时调用DerivedB的构造函数的过程：</p>
<blockquote>
<p>call <code>BaseClass::Constructor()</code></p>
<p>initialize class member <code>base_num</code></p>
<blockquote>
<p>call <code>DerivedA::Constructor()</code></p>
<p>initialize class member <code>derived_a_num</code></p>
<blockquote>
<p>call <code>DerivedA::Constructor()</code></p>
<p>initialize class member <code>derived_b_num</code></p>
</blockquote>
</blockquote>
</blockquote>
<p>  正是因为这样一个机制和顺序：</p>
<ul>
<li>如果基类的<code>默认构造函数</code>、<code>拷贝赋值</code>、<code>移动赋值</code>、<code>析构函数</code>这些是<code>delete</code>或<code>private</code>，则派生类的这些成员也会被定义为<code>delete</code></li>
<li>如果基类有一个<strong>不可访问</strong>或者<strong>删除</strong>的<code>析构函数</code>，则派生类合成的<code>默认构造/拷贝构造/移动构造函数</code>也是<code>delete</code></li>
</ul>
</li>
<li><p>书写派生类的拷贝控制成员</p>
<ul>
<li><p>定义派生类的<strong>拷贝&#x2F;移动构造函数</strong>：通常显式地调用基类的构造函数进行初始化</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span>&#123;&#125;;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">D</span> : Base&#123;</span><br><span class="line">    <span class="built_in">D</span>(<span class="type">const</span> D&amp; d) : <span class="built_in">Base</span>(d)&#123;            <span class="comment">// call Base::copy_constructor to init member of Base</span></span><br><span class="line">        <span class="comment">// init member of D</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">D</span>(D&amp;&amp; d) : <span class="built_in">Base</span>(std::<span class="built_in">move</span>(d))&#123;      <span class="comment">// call Base::move_constructor to init member of Base</span></span><br><span class="line">        <span class="comment">// init member of D</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
<li><p>定义派生类的<strong>拷贝&#x2F;移动赋值运算符</strong>：显式地调用基类的赋值运算符为基类赋值</p>
  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">D&amp; <span class="title">operator</span><span class="params">(<span class="type">const</span> D&amp; rhs)</span></span>&#123;</span><br><span class="line">    Base::<span class="keyword">operator</span>=(rhs);            <span class="comment">// call operator= explicitly</span></span><br><span class="line">    <span class="comment">// handle member of the derived class</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">D&amp; <span class="title">operator</span><span class="params">(D&amp;&amp; rhs)</span></span>&#123;</span><br><span class="line">    Base::Operator=(rhs);            <span class="comment">// call operator= explicitly</span></span><br><span class="line">    <span class="comment">// handle member of the derived class</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>定义派生类的<strong>析构函数</strong>：<strong>派生类的析构函数只负责销毁自己分配的资源</strong>；</p>
<p>  在析构函数体执行完后，类成员会依次进行销毁；类似的，<strong>基类成员也是隐式销毁的</strong>；<strong>对象销毁的顺序与创建相反，先执行派生类的析构函数，然后再调用基类的析构函数</strong>；<strong>先销毁派生类的成员，再销毁基类的成员</strong>；</p>
  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">D</span> : <span class="keyword">public</span> Base&#123;</span><br><span class="line">    ~<span class="built_in">D</span>()&#123;</span><br><span class="line">        <span class="comment">// do this class member clean</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Base::~Base();        // the destructor of base class will be called AFTER the</span></span><br><span class="line">                             <span class="comment">// derived class destructor body automaticly</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>在构造函数和析构函数中使用虚函数</p>
<p>  如我们所知，派生类的<strong>基类部分先被初始化</strong>；当执行基类的构造函数的时候，此时该对象的<strong>派生部分是未被初始化的</strong>；类似当执行<strong>基类的析构函数</strong>的时候，<strong>派生类的部分已经被销毁</strong>了；这两种情况，对象都处于<strong>未完成状态</strong>；</p>
<p>  <strong>在未完成状态，如果构造函数或者析构函数调用了某个虚函数，则我们应该执行当前构造函数或者析构函数对应的类的虚函数版本</strong>；</p>
</li>
<li><p>继承构造函数</p>
<p>  在C++11新标准中，如果派生类的构造函数没有特别要处理的，派生类可以<strong>直接继承</strong>其<strong>直接基类</strong>的构造函数而<strong>不用自己再显式定义</strong>；</p>
  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Base</span>&#123;</span><br><span class="line">    <span class="built_in">Base</span>(<span class="type">int</span> num_, <span class="type">float</span> price_): <span class="built_in">num</span>(num_), <span class="built_in">price</span>(price_)&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derived</span>: <span class="keyword">public</span> Base&#123;</span><br><span class="line">    <span class="comment">// inherit constructor from direct base class</span></span><br><span class="line">    <span class="keyword">using</span> Base::Base;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">double</span> <span class="title">func</span><span class="params">(<span class="type">int</span> a)</span></span>&#123;&#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>  通常情况，<code>using</code>语句只是令某个名字在当前作用域可见；但是当<code>using</code><strong>作用于构造函数的时候</strong>，<code>using</code>语句将<strong>令编译器生成代码</strong></p>
  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> Base::Base; </span><br><span class="line"><span class="comment">// 等价于：</span></span><br><span class="line">Derived::<span class="built_in">Derived</span>(<span class="type">int</span> num_, <span class="type">float</span> price_): <span class="built_in">Base</span>(num_, price_)&#123;&#125;;</span><br></pre></td></tr></table></figure>

<p>  继承的构造函数无法指定<code>explicit</code>和<code>constexpr</code>的关键字，但是会<strong>继承基类的这些关键字</strong>；</p>
<p>  基类构造函数的<strong>默认参数不会被继承</strong>；相反派生类会<strong>得到多个继承的构造函数</strong>：每个函数分别省略掉一个含有默认实参的形参</p>
<p>  如果基类有多个构造函数，则派生类会<strong>继承所有这些构造函数</strong>；派生类可以只继承一部分构造函数，不想继承的可以定义自己的版本去<strong>隐藏</strong>(<em>hidden</em>)基类相同的构造函数</p>
<p>  <strong>默认、拷贝、移动构造函数不可以被继承</strong>，这些函数按照正常规则去合成</p>
</li>
</ul>
<h3 id="Container-and-Inheritance"><a href="#Container-and-Inheritance" class="headerlink" title="Container and Inheritance"></a>Container and Inheritance</h3><ul>
<li><p>容器与继承</p>
<p>  当我们希望使<strong>用容器保存有继承关系的对象</strong>的时候，最好的选择是<strong>保存基类的智能指针</strong></p>
<ul>
<li>不能使用派生类对象，因为基类对象一般不能转换为派生类对象</li>
<li>也不能保存基类对象，因为派生类对象转换为基类之后就丧生了派生类独有的那一部分成员了</li>
<li>也不能保存基类的引用，因为引用是要在定义的时候就初始化的，<strong>无法动态添加删除，也无法赋值</strong>；</li>
<li>动态绑定除了基类引用，就剩下<strong>基类指针</strong>；在动态绑定方面，智能指针有和内置指针的性质</li>
</ul>
  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">std::vector&lt;std::shared_ptr&lt;Base&gt;&gt; vec;</span><br><span class="line">vec.<span class="built_in">push_back</span>(std::<span class="built_in">make_shared</span>&lt;Base&gt;());</span><br><span class="line">vec.<span class="built_in">push_back</span>(std::<span class="built_in">make_shared</span>&lt;Derived&gt;());</span><br></pre></td></tr></table></figure></li>
</ul>

    </div>

    
    
    
      


    <footer class="post-footer">
          

<div class="post-copyright">
<ul>
  <li class="post-copyright-author">
      <strong>本文作者： </strong>PangWong
  </li>
  <li class="post-copyright-link">
      <strong>本文链接：</strong>
      <a href="https://pangwong.github.io/blog/2022/06/cpp-primer-chapter15/" title="Reading Note of CppPrimer-Chapter15">https://pangwong.github.io/blog/2022/06/cpp-primer-chapter15/</a>
  </li>
  <li class="post-copyright-license">
    <strong>版权声明： </strong>本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" rel="noopener" target="_blank"><i class="fab fa-fw fa-creative-commons"></i>BY-NC-SA</a> 许可协议。转载请注明出处！
  </li>
</ul>
</div>

          <div class="post-tags">
              <a href="/tags/reading-notes/" rel="tag"><i class="fa fa-tag"></i> reading notes</a>
              <a href="/tags/cpp-primer/" rel="tag"><i class="fa fa-tag"></i> cpp-primer</a>
              <a href="/tags/base-class/" rel="tag"><i class="fa fa-tag"></i> base class</a>
              <a href="/tags/derived-class/" rel="tag"><i class="fa fa-tag"></i> derived class</a>
              <a href="/tags/inheritance/" rel="tag"><i class="fa fa-tag"></i> inheritance</a>
              <a href="/tags/public-protected-private/" rel="tag"><i class="fa fa-tag"></i> public/protected/private</a>
              <a href="/tags/override/" rel="tag"><i class="fa fa-tag"></i> override</a>
              <a href="/tags/final/" rel="tag"><i class="fa fa-tag"></i> final</a>
              <a href="/tags/dynamic-binding/" rel="tag"><i class="fa fa-tag"></i> dynamic binding</a>
              <a href="/tags/virtual-function/" rel="tag"><i class="fa fa-tag"></i> virtual function</a>
              <a href="/tags/slice-down/" rel="tag"><i class="fa fa-tag"></i> slice down</a>
              <a href="/tags/pure-virtual-function/" rel="tag"><i class="fa fa-tag"></i> pure virtual function</a>
              <a href="/tags/abstract-base-class/" rel="tag"><i class="fa fa-tag"></i> abstract base class</a>
              <a href="/tags/member-hidden/" rel="tag"><i class="fa fa-tag"></i> member hidden</a>
          </div>

        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/blog/2022/06/cpp-primer-chapter16/" rel="prev" title="Reading Note of CppPrimer-Chapter16">
                  <i class="fa fa-chevron-left"></i> Reading Note of CppPrimer-Chapter16
                </a>
            </div>
            <div class="post-nav-item">
                <a href="/blog/2022/06/cpp-primer-chapter14/" rel="next" title="Reading Note of CppPrimer-Chapter14">
                  Reading Note of CppPrimer-Chapter14 <i class="fa fa-chevron-right"></i>
                </a>
            </div>
          </div>
    </footer>
  </article>
</div>






    <div class="comments gitalk-container"></div>
</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">


<div class="copyright">
  &copy; 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">PangWong</span>
</div>
<div class="wordcount">
  <span class="post-meta-item">
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-line"></i>
    </span>
      <span>站点总字数：</span>
    <span title="站点总字数">270k</span>
  </span>
  <span class="post-meta-item">
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
      <span>站点阅读时长 &asymp;</span>
    <span title="站点阅读时长">4:06</span>
  </span>
</div>
<div class="busuanzi-count">
    <span class="post-meta-item" id="busuanzi_container_site_uv">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-item" id="busuanzi_container_site_pv">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>

    </div>
  </footer>

  
  <script src="https://cdn.jsdelivr.net/npm/animejs@3.2.1/lib/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/medium-zoom@1.0.6/dist/medium-zoom.min.js" integrity="sha256-EdPgYcPk/IIrw7FYeuJQexva49pVRZNmt3LculEr7zM=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/lozad@1.16.0/dist/lozad.min.js" integrity="sha256-mOFREFhqmHeQbXpK2lp4nA3qooVgACfh88fpJftLBbc=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/pangu@4.0.7/dist/browser/pangu.min.js" integrity="sha256-j+yj56cdEY2CwkVtGyz18fNybFGpMGJ8JxG3GSyO2+I=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/schemes/muse.js"></script><script src="/js/next-boot.js"></script>

  





  
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>




<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/gitalk@1.7.2/dist/gitalk.css" integrity="sha256-AJnUHL7dBv6PGaeyPQJcgQPDjt/Hn/PvYZde1iqfp8U=" crossorigin="anonymous">

<script class="next-config" data-name="gitalk" type="application/json">{"enable":true,"github_id":"pangwong","repo":"pangwong.github.io","client_id":"c3a7ca3ecf4f08f74acb","client_secret":"db3623e99a388c18ba10413186f9051a35cb6627","admin_user":"pangwong","distraction_free_mode":true,"proxy":"https://cors-anywhere.azm.workers.dev/https://github.com/login/oauth/access_token","language":null,"js":{"url":"https://cdn.jsdelivr.net/npm/gitalk@1.7.2/dist/gitalk.min.js","integrity":"sha256-Pmj85ojLaPOWwRtlMJwmezB/Qg8BzvJp5eTzvXaYAfA="},"path_md5":"656c62a6f4fc7a8cd249d399ee349e7d"}</script>
<script src="/js/third-party/comments/gitalk.js"></script>

</body>
</html>
